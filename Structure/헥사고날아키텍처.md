
https://tech.kakaopay.com/post/home-hexagonal-architecture/ 

- 카카오 페이 홈의 전체 콘텐츠를 Server Driven UI 로 구현하기 위해 단일 API 로 구성
  -> 단일 API 는 정말 말그대로 단일 API 로 API 가 하나로 홈에 필요한 모든 것들을 다 json 타입으로 던저줌 (속도 빠름)

*Proxy Server 역할 참고
- 인증 토큰 붙이기
- 여러 API 합치기(BFF)
- 필드 가공
- 보안 필터링
- cors 우회 등

- 연동 api 의 응답의 스펙이나 값이 바뀔 경우 값을 검증할 기회없이 클라이언트로 전달되는 문제 존재
- 외부 의존성 문제


- 해결 방법
    1. 프로세스를 통한 해결, '연동 API 인터페이스'
       연동 api 인터페이스 표준 api 스펙 정의
       연동 부서에서 특정 스펙에 맞춰 홈 서버에 api 에 응답하면 약속된 형태로 클라이언트에 반환할 수 있는 api 스펙 생성
       -> 어드민에 등록되어 있는 정보와 해당 연동 API 응답을 교차 검증, 활용하여 카드 응답 생성
       -> 콘텐츠를 어떻게 보여줄지에 대한 책임이 각 연동 부서로 넘어가서 홈 서버는 외부 서비스의 세세한 변경에 일일이 대응할 필요가 없어짐

    2. 아키텍처를 통한 해결 'Hexagonal Architecture'
    - 인터페이스에 맞지 않는 레거시 API 존재
    - 앞으로 추가될 연동 불확실성

  *** 외부의 변화가 우리 서버의 핵심 로직(도메인)에 침투하지 못하도록 막는 구조적 안전장치가 필요

    - 많은 API 들을 각기 다른 out Port 로 추상화하여 Hexagonal Architecture 적용
    - Hexagonal Architecture 적용 이후에는 연동 부서에서 API 응답을 변경하거나 혹은 연동해야 하는 API 가 달라져도 infrastructure 모듈만 수정하여 in Port 인터페이스에만 맞추면 기존 도메인 로직 변경 필요 없음

  *** 두해결책의 모순 : 연동 API 인터페이스로 문제를 해결하고 있기 떄문에 Hexagonal Architecture 효용이 떨어짐
  Domain -> Port -> Adapter 을 매번 새로운 기능을 추가할때마다 개발해야 하는 문제 존재

    - 단점
        - 홈 서버의 아키텍처를 새로운 팀원이 들어올때마다 구조 설명 시간 증가
        - Hexagonal Architecture 에 대해 서로 다른 생각으로 구조적인 강제성을 가져야할 아키텍처가 더 많은 다양성 생성하는 문제
          -> 관리 비용 증가


Hexagonal Architecture 적합한 프로젝트 정리
- 도메인이 확실한 서비스
    - 도메인 모델이 명확하지 않은 경우, Hexagonal Architecture 의 핵심 요소인 Port 와 Adapter 의 경계를 설정하는 데서 어려움이 발생 가능
- 외부 의존성이 많지 않는 서비스
    - 로직의 대부분이 연동 api 에 의해 동작하는 서비스일 경우 Port 와 Adapter 에 로직 과중될 확률이 많다.
      -> 참고 : ( 댓글에서 : 즉 해당 맥락에서 외부 의존성은 코드 레벨에서 API 클라이언트가 많다는 혹은 포트가 많다는 부분만 포함하는 것이 아니라 홈이라는 서비스 관점 더 나아가 조직적 관점에서의 외부 의존성을 포함하는 개념입니다.)
- 코어 모듈을 사용하는 모듈이 2개 이상 서비스
    - 코어 모듈을 2개 이상의 서비스가 사용하지 않으면 out Port 에 해당하는 부분만 추상화하는 것이 더 나은 방향

결론 : 프로젝트의 본질적인 특성과 도메인에 대한 이해 선행 필요
헥사고날 아키텍처의 핵심은 핵심 비즈니스 로직 지키고 어댑터 부분 해결


클린 아키텍처 : 비즈니스 규칙이 외부로부터 독립적으로 만들어 테스트를 용이하게 하고, 비즈니스 규칙이 외부의 영향을 받지 않는다.

- 도메인 코드가 바깥으로 향하는 어떠한 의존성도 없어야 한다. 모든 의존성을 안쪽을 향한다.
- 도메인은 어떤 영속성 프레임워크가 사용되는지 알 수 없다. 





------------------------


헥사고날 아키텍처는 추상적인 개념의 클린 아키텍처를 구현하는 방법 중 하나 -> 그 구현 방식 때문에 포트 앤 어댑터(Port & Adapter) 아키텍처 
도메인 계층으로 들어오거나 나가는 계층간의 요청/응답은 Port 라는 인터페이스를 통해 정의 






포트(Ports) : 애플리케이션 코어가 외부와 상호작용하기 위해 마련한 공식적인 통로 (인터페이스)
인커밍포트, 드라이빙 포트 : 자신이 외부로부터 어떤 요청을 받아들일 수 있는지 확인 
아웃고잉 포트, 드리븐 포트 : 외부 시스템으로부터 어떤 기능을 제공받아야 하는지 
- Input Port 이용하는 대표 Adapter : REST API 요청 처리하는 웹 어댑터 (User interface 계층)
- Output Port : 데이터베이스에 데이터를 저장하고 불러오는 역할을 하는 영속성 어댑터 (Infrastructure 계층)


 
어댑터(Adapters) : 외부 요청을 코어가 이해할 수 있는 형태로 변환하여 인커밍포트(useCase)를 통해 전달, 코어가 아웃고잉 포트를 통해 
요청한 작업을 특정 기술(데이터베이스, 메시징 시스템, 외부 api 등)을 사용하여 실제로 수행 
Port 의 인터페이스를 구현한 구현체 


중요 : 의존성의 방향 
모든 의존성이 반드시 외부에서 내부, 즉 애플리케이션 코어를 향해야 한다. 

내부 (애플리케이션 코어) 
- OrderUseCase(인커밍 포트 인터페이스): 주문 생성, 조회 등 애플리케이션이 제공하는 기능 정의 
- OrderService (유스케이스 구현체): OrderUseCase 인터페이스를 실제 비즈니스 로직으로 구현하며, Order 엔티티와 같은 도메인 모델 사용   
- Order (도메인 모델) : 주문과 관련된 상태와 행위를 가지는 핵심 도메인 객체 
- OrderPort(아웃고잉 포트 인터페이스) : 주문 데이터를 영속화하거나 조회하기 위한 메서드 정의 (method query 등)


외부 (어댑터)
- OrderController(인커밍 어댑터) : HTTP 요청을 받아 OrderUseCase 인터페이스 호출 
- OrderPersistenceAdapter (아웃고잉 어댑터) : OrderPort 인터페이스를 JPA 기술을 사용하여 구현


1. 테스트 용이성 (Enhanced Testability)
- 외부 의존성을 목(Mock) 객체라는 가짜 대역을 통해 손쉽게 제어 가능 


2. 향상된 유지보수성 및 유연성 (Improved Maintainability & Flexibility)
- db 등 변경시 해당 아웃고잉 어댑터만 새로 개발하여 교체하면 된다. 
- 새로운 알림 채널(슬랙등) 이나 api 클라이언트를 추가할때도 기존 로직에 영향 주지 않고 새 어댑터만 구현 가능 


3. 강력한 도메인 집중 (Stronger Focus on the Domain)

참고 : https://blog.naver.com/naverfinancial/223155125321 



# 실제 문제점 

- 팀 전체의 이해 
- 기존 코드 구조와의 충돌 
  - 기존 : Controller -> Service -> Repository(JPA)
  - 헥사고날 구조 : Controller(Primary Adapters) -> Application Service / Use Case 
    -> Ports (Interfaces) -> Infrastructure Adapters (JPA, Feign 등 )
- 너무 많은 인터페이스 생성 (불필요한 추상화) 
- 헥사고날 아키텍처는 기존 레이어드보다 더 복잡하다. 장기적으로 유지보수성이 극적으로 좋아진다. 
- 팀 내 공유된 이해 필요 (컨벤션, 예시 코드, 문서화가 매우 중요)
- 왜 이걸 하는가? 
    - 도메인 로직이 외부 기술에 묶이지 않게 한다.
    - 기술 스택 변경이 쉬워진다.
    - 테스트가 엄청 쉬워진다. -> 단위 테스트, 시나리오 테스트가 매우 쉽다. 
    - 복잡해지는 비즈니스 로직을 견디는 구조가 된다. -> 비즈니스가 커질 수록 추상화의 가치가 발휘 
    - 코드 재사용과 유지보수가 쉽다. 
- 트랜잭션 경계에 대한 고민
  트랜잭션 경계가 헷갈린다
  보통 Spring에서는 서비스 계층에 @Transactional을 붙여 해결하지만,
  헥사고날 도입 후에는:

Application Layer에 붙여야 할까?
Adapter Layer에 붙여야 할까?
Domain Event 처리 시 트랜잭션을 어떻게 나눌까?

이런 고민이 생기고, 잘못 설계하면:

Lazy Loading 문제
N+1 문제
트랜잭션 분리 문제
데이터 불일치

같은 실무 버그가 생김.

- 도메인 복잡성이 충분한가? 


***** 도입하고자 하는 이유 
여러 중소기업 회사의 NEEDS 를 파악하여 회사에 맞춰서 개발한다? 
회사가 쓰이는 여러 API 가 늘어날 수 있음 (각 개별 회사별로 요구사항이 달라질 수 있음)
인증 방식도 다양함 
응답 포멧도 제각각
장애/지연 패턴도 다름 
각각 중소기업등에 맞춤 서비스로 개발될 것인가? 
아니면 하나의 배포 시스템에서 DB 로 회사별로 분기할 것인가? 
프론트에서 들어본 이야기로는 -> 혜경님이 다른 서비스 하시는 분을 만났는데, 
API 프론트에서 필요한 것들을 중간에서 합치는 작업을 해서 여러 API 호출이 아닌 1개의 API 호출 사용가능하도록 함 

- 외부 시스템이나 인프라와의 의존성을 낮춰서 구성 요소 쉽게 교체하거나 업데이트 가능
- 테스트 가능성 -> 여러 회사의 다른 개발등과 상관없이 메인 로직에 대한 테스트 가능

의존성을 다 끊어버리고 메인에 집중하여, 확장성을 높이고 싶다. 
헥사고날 아키텍처에서는 OutputPort 인터페이스를 통해 외부 시스템과의 의존성 분리 
인터페이스를 구현하여 새로운 어댑터 생성 


헥사고날(Ports & Adapters): *“비즈니스 핵심은 기술·플랫폼·외부 API 변화로부터 격리한다”*는 아키텍처적 경계와 의존성 방향을 강제
도메인이 소유 

그냥 인터페이스 패턴은 도메인/서비스가 외부 기술 인터페이스에 의존하거나, 인터페이스의 소유가 인프라 측에 있음 -> 결과적으로 의존성 방향이 뒤섞임 
헥사고날은 인터페이스(Port) 는 도메인, 애플리케이션 레이어가 소유 
Adapter 는 Port 를 구현하는 인프라세부(HTTP, JPA, KAFKA 등)
의존성은 항상 밖 -> 안이 아니라 안 -> 밖 호출이

도메인을 엔티티로 변환하는 과정이 존재한다. 
도메인 객체와 엔티티 객체를 분리하여 두개를 작성하는 것이 필요 


1. 매개변수로 받은 객체를 도메인 객체로 변환 작업
2. 비밀번호 암호화 로직 호출 (비즈니스 로직 호출)
3. port 로 Member 도메인을 전송해서 저장 요청 (데이터 저장 요청)
4. 저장된 Member 도메인을 DTO 작업으로 변환 (변환작업)



변환 -> 도메인의 비즈니스 로직 호출 -> port 로 저장 요청 -> 변환 
서비스가 하는 일 : 변환 -> 도메인의 비즈니스 로직 호출 -> port 로 저장 요청 -> 변환 
스프링에서는 호출된 어댑터(in) 가 필요로 하는 useCase 의 구현체를 알아서 찾아 의존성 역전 원칙 주입 


헥사고날 아키텍처에서 클래스(구현체)의 동작은 기존과 동일하게 controller -> service -> adapter(repository) 순서로 흘러가겠지만 이 클래스들이 각각 useCase , port라는 인터페이스를 구현하고 있기 때문에 스프링의 지원을 받아 각 인터페이스에 필요한(스프링 빈) 구현체를 주입받게 된다. 즉, service 클래스에서 adapter 구현체를 직접 의존하는 것이 아니라 port라는 인터페이스를 의존하게 되면서 '의존성 역전'이 적용되었으며 덕분에 헥사고날 아키텍처에서는 이런 의존성 방향성을 가지게 된다.
출처: https://curiousjinan.tistory.com/entry/spring-hexagonal-architecture [오늘도 개발중입니다:티스토리]


단점
- 구현의 복잡성 : 포트와 어댑터를 구성하고 관리하는 데 약간의 복잡성
- 초반 개발 시간 증가
- 팀구성원간의 이해 필요 



-> 도메인은 외부 API 변화의 영향을 받지 않는다. 


대신 추천하는 전략 : Light Hexagonal (경량 포트/어댑터 방식) 또는 도메인만 분리 
- 핵심적인 외부 연동만 Port 로 추상화하고, 나머지는 기존 구조 유지 

Port 로 감싸야 할것 
- AI Server Client
- 외부 자동화 API 
- 외부 결제/인증 시스템 

굳이 Port 로 만들 필요 없는 것
- 내부 간단 CRUD 
- 단순 조회 API 
- 비즈니스가 안정되지 않은 모듈

핵심적인 것만 적용 : 아키텍처 복잡도 증가 없음, 팀 생산성 유지 가능, 변경에도 유연, 기술 의존성 잘 분리 




https://tech.osci.kr/hexagonal-architecture/