# 멀티모듈 구조의 문제점 고려 

- domain 은 Spring 에 종속되지 않게 개발 
- api 에서 repository 직접 호출 하지 않음 
- common 에 전부 넣기 
- 모듈 쪼갰지만 의존성을 뒤죽박죽 처리 


모놀리식 아키텍처의 한계로 MSA 가 시작함 
전통적인 모놀리식 아키텍처는 애플리케이션의 규모가 커짐에 따라 개발 속도가 느리고, 배포나 유지보수에 어려움을 겪는다.
애자일 방법론의 도입으로 빠른 개발과 배포가 강조되었고 MSA 가 떠오르게 됨 
클라우드 컴퓨팅의 발전 : 클라우드 환경이 발전하면서 MSA 구축과 운영이 용이 
넷플릭스가 도입함 
- 하나의 서비스에 문제가 생겨도 전체 서비스 시스템에는 영향 최소화 설계


# 넷플릭스식 MSA: 핵심 컴포넌트 & 패턴 

1. API Gateway : 단일 진입점 
- MSA 에서는 클라이언트가 바로 여러 서비스 endpoint 를 호출불가하기 때문에 API Gateway 가 라우팅 필요 
- Zuul 를 내부 게이트웨이로 활용함 
- 클라이언트 요청을 각 서비스로 프록시/라우팅 
- 인증/인가/로깅처리 
요청 분할(aggregate) 및 응답 결합 


2. Service Discovery 
MSA 에서는 서비스가 동적으로 늘어나거나 줄어들기 때문에 중앙에서 위치를 조회필요 
넷플릭스가 만든 Eureka 대표 
쿠버네티스 Service 가 역할 대신 가능 


3. Load Balancing - 부하 분산 
- 각 서비스 인스턴스 사이에 트래픽을 효율적으로 나누기 위한 로드밸런서가 필요 
- 넷플릭스는 Ribbon 같은 클라이언트 사이드 로드밸런서를 썼고, 지금은 클라우드/서비스 메쉬 수준에서 해결함 


4. Resilience / Fault Tolerance - 장애 격리 
- 장애 전파를 막고 복원력을 높이기 위해 서킷 브레이커 패턴 적극 활용 



5. Configuration Management : 설정 중앙화 
- 서비스가 많아지면 개별 설정 파일로 관리가 힘들어짐 
Archaius 를 만들어 설정을 중앙화/동적 반영 가능


6. Logging, Monitoring, Tracing : 작업 상태 관찰 
- 서비스가 많아지면 로그/메트릭이 여러 곳으로 흩어지기 때문에 중앙 집중형 모니터링 필수 
- ELK (ElasticSearch + Logstash + Kibana)
- APM / Tracing (Zipkin, Jaeger)
- 메트릭 수집(Prometheus, Atlas)


7. Continuous Delivery / DevOps 
- 넷플릭스는 Spinnaker 라는 자체 CD 툴로 매일 수천 번의 배포를 무중단 처리함 


MSA 에서 자주 쓰는 설계 패턴들 

1. Database per Service 
각 서비스가 자기 DB(데이터 저장소)를 갖는 방식 : 데이터 소유권을 명확히 하고 독립 배포를 가능하게 함
2. SAGA 패턴
- 분산 트랜잭션을 처리하기 위한 대표 패턴 
- 긴 트랜잭션을 작은 로컬 트랜잭션 여러개로 분리, 실패 시 보상 트랜잭션으로 롤백 처리함 
- 한 요청이 여러 서비스 DB 를 건드릴 때 (주문 생성, 결제 승인, 재고 차감, 포인트 적립등)
- Choreography (이벤트 기반)
- Orchestration (중앙 제어)
  Saga Orchestrator
  ↓
  Order → Payment → Inventory → Done


3. Event-Driven Architecture 
- 서비스 간 이벤트 큐를 사용해 느슨하게 결합됨 - Kafka, RabbitMQ 같은 메시징 시스템 활용 
- 이벤트 커뮤니케이션시 비동기 처리로 응답 속도 개선, 장애 확산 방지, 느슨한 결합이 발생함
4. Backend for Frontend(BFF)
- 클라이언트 종류별로 맞춘 백엔드 레이어를 따로 두는 패턴
- 넷플릭스는 여러 디바이스 UX 를 고려해서 이 패턴 적용 
5. Service Mesh
- 서비스 간 통신을 인프라 게층이 처리 
- 로드밸런싱, 인증, 모니터링을 중앙화로 처리 

6. Polyglot Persistence : 서비스 목적에 따라 서로 다른 데이터 저장소를 쓰는 전략 


# MSA 의 장점과 단점

1. 장점
   - 빠른 개발 및 배포 : 각 서비스는 독립적으로 개발, 배포 가능 개발 속도 높이고 배포 주기 단축
   - 유연한 확장성 : 특정 서비스의 트래픽이 증가하면 해당 서비스만 확장 가능 
   - 장애 격리 : 특정 서비스에 장애가 발생하더라도 다른 서비스에는 영향 주지 않는다. 
   - 기술 다양성 : 각 서비스는 필요에 따라 최적의 기술 스택선택 가능
   - 팀 자율성 : 각 서비스는 독립적인 팀에서 개발, 관리 가능 
2. 단점
   - 운영 복잡성 증가 
   - 서비스 간 통신 비용 발생
   - 분산 시스템의 복잡성 : 트랜잭션 관리, 데이터 일관성, 장애 처리 등 다양한 문제에 대한 고려 필요 
   - 테스트 복잡성 증가 

*클린 아키텍처, 헥사고날 아키텍처, DDD 레이어드 아키텍처 

# 모듈형 모놀리스(Modular Monolith)
배포는 하나(모놀리스)지만, 내부 구조는 여러 개의 작은 서비스처럼 분리된 아키텍처 

모듈형 모놀리스는 잘 설계된 모놀리스 이고 MSA 로 가기 위한 가장 현실적인 출발점
멀티모듈 물리 구조 선택지


모놀리스 
- 코드가 한 덩어리로 얽힘 

MSA 
- 네트워크 지옥
- 배포/운영 난이도 급상승
- 트랜잭션 관리 지옥
-> 내부는 MSA 처럼 외부는 모놀리스 처럼 

공유 가능한 것 
- 공통 에러 타입
- 로깅
- 프레임워크 설정

공유하면 안되는 것 
- 비즈니스 로직
- 엔티티
- Repository 


| 항목     | 모놀리스  | 모듈형 모놀리스 | MSA    |
| ------ | ----- | -------- | ------ |
| 배포     | 하나    | 하나       | 여러 개   |
| 내부 구조  | 뒤엉킴   | 모듈 분리    | 서비스 분리 |
| 통신     | 내부 호출 | 내부 + 이벤트 | 네트워크   |
| 운영 난이도 | 쉬움    | 쉬움       | 어려움    |
| 확장성    | 낮음    | 중간       | 높음     |


| 패턴              | 언제 쓰는가      |
| --------------- | ----------- |
| SAGA            | 여러 서비스 트랜잭션 |
| Event Driven    | 비동기 작업      |
| Circuit Breaker | 외부 호출       |
| BFF             | 클라이언트 다양    |
| API Gateway     | 모든 MSA      |
| DB per Service  | 서비스 분리 시    |



회사들이 많이 쓰는 구조 
모듈형 모놀리스 기반 + 점진적 분리전략 (사이즈가 커지게 되면)

1위 - 도메인 기반 모듈형 모놀리스 (업계 표준)

- 배포는 하나 
- DB 는 하나 
- 도메인 단위 패키지/모듈 분리 
- 모듈 간 인터페이스 호출
- 배포 단순
- 트랜잭션 쉬움


2위 - 모듈형 모놀리스 + 일부만 MSA (Strangler Pattern)


3위 - 레이어드 모놀리스 
controller, service, repository, domain 


MSA 의 단점 
- 서비스 간 네트워크 지연
- 장애 추적 어려움
- 배포 파이프라인 복잡
- 운영 인력 필요 
- 트랜잭션 처리 어려움 
- 


조금더 고려할 것 
- 헥사고날 아키텍처 (Hexagonal Architecture) : 애플리케이션 핵심 비즈니스 로직을 외부 기술로부터 완전히 분리 
- 포트와 어댑터 패턴** 
비즈니스 로직을 중심에 두고 외부기술(DB, 웹, API) 을 플러그처럼 꽂는 구조 
Controller -> Service -> Repository -> DB 
  - Service 가 DB 에 의존
  - DB 바꾸면 서비스 코드 수정 필수 
  - 테스트 어려움 
  - 프레임워크 있어야 코드 존재 

        [ Web API ]
             │
        (Inbound Adapter)
             │
        ┌─────────────┐
        │  Application │
        │    & Domain  │  ← 핵심 (기술 모름)
        └─────────────┘
             │
        (Outbound Port)
             │
    [ DB / Kafka / 외부 API ]
    (Outbound Adapter)

Ports 
핵심 로직과 외부 세계를 연결하는 인터페이스 
Inbound Port : 애플리케이션으로 들어오는 요청
Outbound Port : 애플리케이션이 외부에 요청 

Adapters : 포트를 실제로 구현하는 구체적인 코드 
Inbound Adapter: Rest API, GraphQl, CLI 등 
Outbound Adapter: MySql, MongoDB, Kafka, 외부 API 클라이언트 등 



┌─────────────────────────────────────┐
│      Inbound Adapters               │
│  (REST, gRPC, CLI, Queue Consumer)  │
└──────────────┬──────────────────────┘
│
[Inbound Ports]
│
┌──────────────▼──────────────────────┐
│    Application Core (핵심 로직)      │
│                                     │
│  • Domain Models                    │
│  • Business Rules                   │
│  • Use Cases                        │
└──────────────┬──────────────────────┘
│
[Outbound Ports]
│
┌──────────────▼──────────────────────┐
│      Outbound Adapters              │
│   (DB, Cache, Message Queue, APIs)  │
└─────────────────────────────────────┘

장점
- 핵심 로직을 Mock 어댑터로 독립적으로 테스트 가능 
- 실제 DB 없이도 비즈니스 로직 검증 
- 기술독립성 지님 (DB 변경시 어댑터만 교체)
- REST -> gRPC 전환 시 핵심 로직 변경 불필요 
- 비즈니스 로직과 기술 구현이 명확히 분리 
- 기술이 아닌 비즈니스에 집중 가능 

실무적용시 
- 소규모 프로젝트에서는 과도한 추상화일 수 있다. 
- 초기 구조 설계에 시간 투자 필요 
- 팀원들의 아키텍처 이해도 중요 


# 실무에 적용 
모듈형 모놀리스 + 헥사고날 구조 

Application (하나의 Spring Boot 앱)
- user 모듈
- order 모듈
- payment 모듈
- common-core 

중요한 점 
- 모듈 간 호출 : 인터페이스 or 이벤트
- 다른 모듈 DB 접근 : X 
- 공통 모듈 : 최소화
- 도메인 기준 분리 : 필수 


각 모듈이 작은 서비스처럼 생긴다. 

order 
- domain 
- application
- adapter 
  - in
  - out 

전체 구조 

app
├─ order
│   ├─ domain
│   ├─ application
│   └─ adapter
│       ├─ in (Controller)
│       └─ out (JPA, Kafka)
│
├─ user
└─ payment


실무에서 꼭 지켜야 할 규칙
- domain 에 @Entity 금지 
- application 에서 JPA import 금지 
- common 에 도메인 넣기 

*고려사항
- 배포는 하나
- 도메인 단위 모듈
- 모듈 내부는 헥사고날
- 나중에 MSA 분리 가능 


구현 스타일 



방식1. Gradle 멀티 모듈 + 헥사고날 (실무 best)

root 
- app (Spring Boot 실행)
- common-core
- order
  - domain
  - application
  - adapter
    - in
    - out 
- user
- payment 


방식2. 단일프로젝트 + 패키지 모듈화 + 헥사고날 
모듈을 패키지로만 나눔
com.project
├─ order
├─ user
├─ payment


방식3. 멀티모듈 + Shared Kernel 최소화 (DDD 스타일) (난이도 높음)
공통 모듈을 극도로 제한 
common-core : 로깅, 예외, 인증 
- 모듈 독립성 최고 
- MSA 전환 거의 자동 
- 설계 난이도 높음 
- 고수팀 스타일 
- 마이크로서비스의 설계 철학 + 모놀리스의 단순함 
  - 내부 이벤트 기반 구조 (In-Process Event Driven)
  - 모듈끼리 직접 함수 호출하지 않고 이벤트로 말 거는 구조 
  ```` 
  // 전통적 구조 
  OrderService
   → PaymentService.pay()
   → UserService.addPoint()
  // 내부 이벤트 방식
  OrderService
   → publish(Event: OrderCreated)
  PaymentModule  : OrderCreated 이벤트 구독 → 결제 처리
  UserModule     : OrderCreated 이벤트 구독 → 포인트 적립
  Notification   : OrderCreated 이벤트 구독 → 알림 발송


방식 4. 모듈형 모놀리스 + 내부 이벤트 기반 구조 
- 모듈간 통신을 서비스 호출 대신 이벤트로
- Order 모듈 -> OrderCreated 이벤트 
- Payment 모듈 -> 이벤트 수신
- 구성 
Order 모듈 -> OrderCreated 이벤트 
Payment 모듈 -> 이벤트 수신 
- MSA 와 거의 동일한 구조 연습
- 느슨한 결합, 복잡도 증가 
MSA 준비 단계 팀들이 많이 씀 


방식 5. Feature 기반 모듈 + 헥사고날 (Vertical Slice)
레이어가 아니라 기능 단위로 완결 
각 기능이 작은 헥사고날 구조
order
├─ create
├─ cancel
└─ pay




| 방식               | 난이도 | 확장성   | 추천도  |
| ---------------- | --- | ----- | ---- |
| Gradle 멀티모듈      | 중   | 매우 높음 | ⭐⭐⭐⭐ |
| 패키지 모듈화          | 낮음  | 낮음    | ⭐⭐   |
| Shared Kernel 최소 | 높음  | 매우 높음 | ⭐⭐⭐  |
| 내부 이벤트 구조        | 중   | 높음    | ⭐⭐⭐⭐ |
| Vertical Slice   | 중   | 높음    | ⭐⭐⭐  |



세가지 먼저 확인해볼것 

| 항목                           | 정체성                |
| ---------------------------- | ------------------ |
| **모듈형 모놀리스 + 내부 이벤트**        | 애플리케이션 구조 전략       |
| **멀티모듈 + Shared Kernel 최소화** | DDD 전략             |
| **Gradle 멀티모듈 + 헥사고날**       | 프로젝트 구성 + 레이어 아키텍처 |


1. 모듈형 모놀리스 + 내부 이벤트 기반 
MSA 처럼 느슨하지만 물리적으로는 하나로 생각 가능

- 기능 추가가 많은 서비스
- 도메인 복잡도 증가 대응
- MSA 준비 단계 
- 모듈간 직접 호출 금지 
- 단일 배포 
- 결합도 낮음
- 기능 추가 쉬움
- MSA 전환 쉬움
- 이벤트 흐름 추적 어려움
- 트랜잭션 관리 까다로운 문제 
- 설계 못하면 이벤트 스파게티 


2. 멀티모듈 + Shared Kernel 최소화 (DDD 스타일)
코드를 어떻게 나눌 것인가에 대한 DDD 전략
모듈형 모놀리스의 도메인 경계를 엄격히 만듬 


Shared Kernel : 여러 도메인이 같이 쓰는 코드 
많이 쓰게 되면 : 모듈 간 결합도가 폭증하며 하나 수정하면 전체 영향이감 

user-module
order-module
payment-module
shared-kernel (거의 비어있음)

- 모듈 독립성 극대화
- MSA 분리 난이도 최저
- 대형 서비스에 강하다
- 코드 중복 증가 
- 설계 난이도 어려움
- Shared Kernel 최소화 필요 


3. Gradle 멀티모듈 + 헥사고날 아키텍처 

- Gradle 멀티모듈 
- 헥사고날 아키텍처 : 도메인은 외부 기술을 몰라야 한다. 
Controller -> Application -> Domain <- Infra(DB, API)



| 항목     | 모듈형 모놀리스+이벤트 | DDD Shared Kernel 최소화 | Gradle 멀티모듈+헥사고날 |
| ------ | ------------ | --------------------- | ---------------- |
| 관심사    | 모듈 간 통신 방식   | 도메인 경계 전략             | 코드 구조 + 의존성 제어   |
| 목표     | 결합도 낮추기      | 도메인 독립성 극대화           | 안정적 구조           |
| 이벤트 사용 | 핵심           | 선택                    | 선택               |
| 코드 공유  | 가능           | 최소화                   | common 정도        |
| MSA 전환 | 쉬움           | 매우 쉬움                 | 쉬움               |
| 실무 채택  | 점점 증가        | 대형 서비스                | 가장 보편적           |
| 난이도    | 중상           | 높음                    | 중상               |


베스트 조합 
구조는 헥사고날 + 멀티모듈 
도메인 경계는 DDD 
통신은 이벤트기반으로 느슨하게 


## 이벤트 

이벤트 : 이미 발생한 사실을 다른 모듈에게 알리는 메시지 
이벤트 처리 구조 생각해보기 




## Hexagonal Architecture 구조 고려
https://tech.kakaopay.com/post/home-hexagonal-architecture/









    
    
    
    
    
    

    


