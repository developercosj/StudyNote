# 데이터 복제 필요성
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간 줄이기
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성 높이기
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

# 복제의 어려움
복제의 어려움은 복제된 데이터의 변경 처리

노드간 복제시 알고리즘 : 단일 리더(single-leader), 다중 리더(multi-leader), 리더 없는(leaderless) 복제


# 트레이드 오프

동기식 복제 vs 비동기식 복제
잘못된 복제본 처리


# 리더와 팔로워


복제 서버 (replica) : 데이터베이스의 복사본 저장하는 각 노드
쓰기 작업은 모든 복제 서버에서 진행되어야 한다. (일관적이게)
일관성을 보장하기 위하여
- 리더 기반 복제 (leader-based replication, active/passive)
- 마스터/ 슬레이브(master/slave)

## 구조 탐구
리더 (마스터, 프라이머리)
팔로워 (follower) (읽기 복제 서버(read replica) (슬레이브 2차 secondary) (핫대기 hot standby)
리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그(replication log)나 변경 스트림(change stream) 의 일부로 팔로워한테 전송
-> 로컬 복사본 갱신
클라이언트가 데이터베이스로부터 읽기시 리더, 임의 팔로워에게 질의할 수 있으나, 쓰기는 리더에게만 허용



# 복제 사용처
- 여러 관계형 데이터베이스 내장 기능이며 몽고 DB, 리싱크 DB, 에스프레소 등 일부 비관계형 데이터베이스, 카프카와 래빗MQ 의 고가용성 큐 같은 분산 메시지 브로커에도 사용
  일부 네트워크 파일 시스템과 DRBD 같은 복제 블럭 디바이스도 유사하다.



# 동기식 대 비동기식 복제
- 복제가 동기식으로 발생하는지 비동기식으로 발생하는지
- 동기식은 리더가 팔로워의 복제 완료를 기다리지만 비동기식은 리더가 팔로워의 복제 완료를 기다리지 않는다.
- 동기식 복제
    - 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
    - 단점으로 동기팔로워가 여러 이유로 응답하지 않으면 쓰기가 처리될 수 없다.
- 비동기식 복제
    - 비동기식 복제는 내구성을 약화시키지만 많은 팔로워가 있을때, 지리적으로 분산됐다면 사용한다.
    - 완전 비동기식 복제는 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있다는 점





  # 리더 장애: 장애 복구
- 장애 복구 (failover) : 팔로워 중 하나를 새로운 리더로 승격하며 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정을 하고 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다.


# 발생할 수 있는 오류 
- 스플릿 브레인(split brain) : 두 노드가 모두 자신이 리더라고 생각, 일부 시스템에는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 메커니즘이 있다. 
- 노드 장애, 불안정한 네트워크, 복제 서버 일관성과 관련된 트레이드 오프, 지속성, 가용성, 지연 시간 




# 복제 로그 구현
1. 구문 기반 복제 
   - MySAL 은 구문에 비결정성이 있다면 기본적으로 로우기반 복제로 변경한다. 
   - 볼트 DB (Volt DB) 도 구문 기반 복제를 사용한다. 
     - 리더 노드에서 실행된 명령문 자체를 그대로 팔로워 노드에 전송
     - 팔로워 노드는 그 명령을 그대로 재실행하여 DB 상태를 동일하게 만든다. 
     - Bolt DB 는 트랜잭션이 결정적이어야 한다 : 읽기-쓰기 트랜잭션 내에서의 키 순서 보장, 트랜잭션은 외부 요인에 영향을 받지 않아야 한다.
2. 쓰기 전 로그 배송
   - 

3. 논리적(로우 기반) 로그 복제

4. 트리거 기반 복제 
   - 데이터의 서브셋만 복제나 다른 종류의 DB 로 이동 
   - 오라클의 골든게이트, 트리거, 스토어드 프로시저 
   - 트리거는 사용자 정의 애플리케이션 코드 등록 가능 



# 복제 지연 문제 

1. 확장성 : 단일 장비에서 감당하지 못하는 요청을 처리 
2. 지연시간 : 사용자에게 지리적으로 더 가까운 복제 서버 위치 
대부분이 읽기 요청이고 쓰기가 아주 작은 비율로 구성된 작업부하라면 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산가능 (웹 상의 공통 패턴)
-> 리더의 부하를 없애고 근처 복제 서버에서 읽기 요청을 처리할 수 있게 해준다. 
읽기 확장 아키텍처에서는 비동기식 복제에서만 동작 (동기식에서는 노드 증가시 다운가능성도 커져 매우 불안정하다.)

3. 쓰기 후 읽기 일관성 (자신의 쓰기 읽기 일관성) : 
  - 사용자가 수정한 내용을 읽을 때에는 리더에서 읽고 그 밖에서는 팔로워에서 읽는다. 
  - (예를들어 사용자 소유 프로필 리더에서 읽고 다른 사용자의 프로필은 팔로워에서 읽기)
  - 마지막 갱신 시간을 찾아서 마지막 갱신 후 1 분 동안은 리더에서 모든 읽기를 수행한다. 
  - 팔로워에서 복제 지연을 모니터링해 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다. 

4. 동일한 사용자가 여러 디바이스 (예를들어 데스크톱 웹 브라우저와 모바일 앱) 로 서비스를 접근할 떄
   - 사용자의 마지막 갱신 타임스탬프를 기억해야 하기 때문에 이 메타데이터는 중앙집중식으로 관리해야 한다. 
   - 복제 서버가 여러 데이터센터 간에 분산돼 있다면, 다른 디바이스의 연결이 동일한 데이터센터로 라우팅된다는 보장이 없다. 
     리더에서 읽어야 할 필요가 있다면 먼저 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야 한다. 



# 단조 읽기 (monotonic read)

- 단조읽기는 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 더 강한 보장 
- 단조읽기를 달성하는 한 방법은 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것 



# 일관된 순서로 읽기 

- 일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다. 
- 데이터베이스가 항상 같은 순서로 쓰기를 적용한다면 읽기는 항상 일관된 순서를 보장하여 문제가 없다.
- 많은 분산 데이터베이스에서 서로 다른 파티션은 독립적으로 동작하기 때문에 쓰기의 전역 순서는 없다. 
-> 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법이 있다. (인과성을 명시적으로 유지하기 위한것은 효율적이진 않지만 알고리즘은 존재)

# 복제 지연을 위한 해결책 
지연이 오래 발생한다면, 쓰기 후 읽기와 같은 강한 보장을 제공하게끔 시스템 설계 필요 
복제가 비동기식으로 동작하지만 동기식으로 동작하도록 보이는 것이 문제 해결 방안이 된다. 
트랜잭션 : 애플리케이션(개발단)이 더 단순해지기 위해 데이터베이스가 강력한 보장 제공 


# 다중 리더 복제 
- 마스터 마스터나 액티브/액티브 복제라고도 함 
- 쓰기 처리를 하는 각 노드는 데이터 변경을 다른 모든 노드에 전달해야 한다. 
- 다중리더 복제의 단점은 동일한 데이터를 다른 두 개의 데이터 센터에서 동시에 변경할 수 있다는 것 
    -> 이때 발생하는 쓰기 충돌은 해결이 반드시 필요하다. 
- 다중 리더 복제가 적절한 상황 예 : 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우 

    디바이스가 현재 인터넷 연결되지 않았어도 회의를 언제나 볼 수 있어야 한다(읽기요청), 언제라도 회의에 참석 가능해야 한다.(쓰기 요청)
    오프라인 상태에서 데이터를 변경하면 디바이스가 다음에 온라인 상태가 됬을 때 서버와 다른 디바이스 동기화 필요 
    모든 디바이스에는 리더처럼 동작하는 로컬 데이터베이스가 있다. (쓰기요청받기) 
    모든 디바이스 상에서 캘린더의 복제 서버 간 다중 리더 복제를 비동기 방식으로 수행하는 프로세스(동기화)가 있다. 
    복제 지연은 사용자가 인터넷 접근이 가능해진 시점에 따라 시간이 오래 소요될 수 있다. 
    *참고 : 카우치 db 

# 협업 편집 

- 한 사용자가 문서를 편집할 때 변경 내용 (웹 브라우저나 클라이언트 애플리케이션의 문서 상태)을 즉시 로컬 복제 서버에 적용하고 나서 동일한 문서를 편집하는 다른 사용자와 서버에 비동기 방식으로 복제
- 편집 충돌이 없음을 보장하기 위해 애플리케이션은 사용자가 편집하기 전에 문서의 잠금을 얻어야 한다. -> 다른 사용자가 수정을 원하면 첫번째 사용자의 변경이 커밋되고 잠금이 해제될 때까지 기다려야 한다. 

# 쓰기 충돌 다루기 
다중 리더 복제에서 제일 큰 문제는 쓰기 충돌 발생한다는 점 
동일한 레코드를 두 리더가 동시에 갱신하면 쓰기 충돌이 발생한다. 


# 동기 대 비동기 충돌 감지 
다중 리더 설정에서는 두 쓰기는 모두 성공해서 충돌은 특정 시점에 비동기로만 감지된다. 
-> 사용자에게 충돌을 해소하게끔 요청하는 것은 어려움 
충돌 감지는 동기식으로 만들 수 있으나 다중 리더 복제의 주요 장점인 각 복제 서버가 독립적으로 허용한다는 점을 잃게 된다. 

# 충돌 회피 
특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않는다. 
사용자가 자신의 데이터를 편집할 수 있는 애플리케이션에서 특정 사용자의 요청을 동일한 데이터센터로 항상 라우팅하고 데이터센터 내 리더를 사용해 읽기와 쓰기를 하게끔 보장 


각 쓰기에 고유 id(타임스탬프, uuid 등)
타임스탬프를 사용하는 경우를 최종 쓰기 승리라 한다. 


























