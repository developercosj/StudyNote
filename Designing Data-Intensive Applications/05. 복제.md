# 데이터 복제 필요성
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간 줄이기
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성 높이기
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

# 복제의 어려움
복제의 어려움은 복제된 데이터의 변경 처리

노드간 복제시 알고리즘 : 단일 리더(single-leader), 다중 리더(multi-leader), 리더 없는(leaderless) 복제


# 트레이드 오프

동기식 복제 vs 비동기식 복제
잘못된 복제본 처리


# 리더와 팔로워


복제 서버 (replica) : 데이터베이스의 복사본 저장하는 각 노드
쓰기 작업은 모든 복제 서버에서 진행되어야 한다. (일관적이게)
일관성을 보장하기 위하여
- 리더 기반 복제 (leader-based replication, active/passive)
- 마스터/ 슬레이브(master/slave)

## 구조 탐구
리더 (마스터, 프라이머리)
팔로워 (follower) (읽기 복제 서버(read replica) (슬레이브 2차 secondary) (핫대기 hot standby)
리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그(replication log)나 변경 스트림(change stream) 의 일부로 팔로워한테 전송
-> 로컬 복사본 갱신
클라이언트가 데이터베이스로부터 읽기시 리더, 임의 팔로워에게 질의할 수 있으나, 쓰기는 리더에게만 허용



# 복제 사용처
- 여러 관계형 데이터베이스 내장 기능이며 몽고 DB, 리싱크 DB, 에스프레소 등 일부 비관계형 데이터베이스, 카프카와 래빗MQ 의 고가용성 큐 같은 분산 메시지 브로커에도 사용
  일부 네트워크 파일 시스템과 DRBD 같은 복제 블럭 디바이스도 유사하다.



# 동기식 대 비동기식 복제
- 복제가 동기식으로 발생하는지 비동기식으로 발생하는지
- 동기식은 리더가 팔로워의 복제 완료를 기다리지만 비동기식은 리더가 팔로워의 복제 완료를 기다리지 않는다.
- 동기식 복제
    - 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
    - 단점으로 동기팔로워가 여러 이유로 응답하지 않으면 쓰기가 처리될 수 없다.
- 비동기식 복제
    - 비동기식 복제는 내구성을 약화시키지만 많은 팔로워가 있을때, 지리적으로 분산됐다면 사용한다.
    - 완전 비동기식 복제는 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있다는 점





  # 리더 장애: 장애 복구
- 장애 복구 (failover) : 팔로워 중 하나를 새로운 리더로 승격하며 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정을 하고 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다.


# 발생할 수 있는 오류 
- 스플릿 브레인(split brain) : 두 노드가 모두 자신이 리더라고 생각, 일부 시스템에는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 메커니즘이 있다. 
- 노드 장애, 불안정한 네트워크, 복제 서버 일관성과 관련된 트레이드 오프, 지속성, 가용성, 지연 시간 




# 복제 로그 구현
1. 구문 기반 복제 
   - MySAL 은 구문에 비결정성이 있다면 기본적으로 로우기반 복제로 변경한다. 
   - 볼트 DB (Volt DB) 도 구문 기반 복제를 사용한다. 
     - 리더 노드에서 실행된 명령문 자체를 그대로 팔로워 노드에 전송
     - 팔로워 노드는 그 명령을 그대로 재실행하여 DB 상태를 동일하게 만든다. 
     - Bolt DB 는 트랜잭션이 결정적이어야 한다 : 읽기-쓰기 트랜잭션 내에서의 키 순서 보장, 트랜잭션은 외부 요인에 영향을 받지 않아야 한다.
2. 쓰기 전 로그 배송
   - 

3. 논리적(로우 기반) 로그 복제

4. 트리거 기반 복제 
   - 데이터의 서브셋만 복제나 다른 종류의 DB 로 이동 
   - 오라클의 골든게이트, 트리거, 스토어드 프로시저 
   - 트리거는 사용자 정의 애플리케이션 코드 등록 가능 



# 복제 지연 문제 

1. 확장성 : 단일 장비에서 감당하지 못하는 요청을 처리 
2. 지연시간 : 사용자에게 지리적으로 더 가까운 복제 서버 위치 
대부분이 읽기 요청이고 쓰기가 아주 작은 비율로 구성된 작업부하라면 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산가능 (웹 상의 공통 패턴)
-> 리더의 부하를 없애고 근처 복제 서버에서 읽기 요청을 처리할 수 있게 해준다. 
읽기 확장 아키텍처에서는 비동기식 복제에서만 동작 (동기식에서는 노드 증가시 다운가능성도 커져 매우 불안정하다.)

3. 쓰기 후 읽기 일관성 (자신의 쓰기 읽기 일관성) : 
  - 사용자가 수정한 내용을 읽을 때에는 리더에서 읽고 그 밖에서는 팔로워에서 읽는다. 
  - (예를들어 사용자 소유 프로필 리더에서 읽고 다른 사용자의 프로필은 팔로워에서 읽기)
  - 마지막 갱신 시간을 찾아서 마지막 갱신 후 1 분 동안은 리더에서 모든 읽기를 수행한다. 
  - 팔로워에서 복제 지연을 모니터링해 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다. 

4. 동일한 사용자가 여러 디바이스 (예를들어 데스크톱 웹 브라우저와 모바일 앱) 로 서비스를 접근할 떄
   - 사용자의 마지막 갱신 타임스탬프를 기억해야 하기 때문에 이 메타데이터는 중앙집중식으로 관리해야 한다. 
   - 복제 서버가 여러 데이터센터 간에 분산돼 있다면, 다른 디바이스의 연결이 동일한 데이터센터로 라우팅된다는 보장이 없다. 
     리더에서 읽어야 할 필요가 있다면 먼저 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야 한다. 



# 단조 읽기 (monotonic read)
    - 단조읽기는 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 더 강한 보장 
    - 단조읽기를 달성하는 한 방법은 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것 





















