*멤케시디 : 메인 db 와 분리된 애플리케이션 관리 캐시 계층
*엘리스틱 서치, 솔라 : 전문 검색 서버
*내부적으로 문제가 있어도 데이터를 정확하고 안전하게 유지하려면 어떻게 해야 할까?
*시스템의 일부 성능이 저하되더라도 클라이언트에 일관되게 좋은 성능을 어떻게 제공할 수 있을까?
*부하 증가를 다루기 위해 어떻게 규모를 확장할까?
*서비스를 위해 좋은 API 는 어떤 모습일까?
*시스템 설계에 영향을 줄 수 있는 많은 요소 : 관련자의 기술 숙련도, 기존 시스템의 의존성, 전달 시간 척도, 다양한 종류의 위험에 대한 조직의 내성, 규제 제약



## 세가지 고려사항

1. 신뢰성 : 하드웨어나 소프트웨어 결함, 심지어 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작 (원하는 성능 수준에서 정확한 기능을 수행) 해야 한다.
2. 확장성 : 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.
3.  유지보수성 : 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업 (현재 작업 유지보수, 새로운 사용 사례 시스템에 적용하는 엔지니어링과 운영) 할때 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야한다.

잘못될 수 있는 일 : 결함 (fault) → 결함을 예측하고 대처할 수 있는 시스템 : 내결함성, 탄력성을 지녔다.
장애 : 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우
결함 확률을 0으로 줄이는 것은 불가능하다. 따라서 대개 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장좋다.

## 하드웨어 장애

- 시스템 장애율 줄이기 위한 첫 번째 대응으로 각 하드웨어 구성 요소에 중복을 추가

    디스크 : RAID 구성으로 설치

    서버 : 이중 전원 디바이스, Hot-swap 가능한 CPU

    데이터 센터는 건전지와 예비 전원용 디젤 발전기


소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템

장비를 재부팅해야 하는 경우 (예를 들어 운영체제 보안 패치를 적용) 단일 서버 시스템은 계획된 중단시간이 필요하지만, 장비 장애를 견딜 수 있는 시스템은 전체 시스템의 중단시간 없이 한 번에 한 노드씩 패치할 수 있다.


## 소프트웨어 오류 

시스템 내 체계적 오류 
CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
연쇄 장애 


해결하기 위해서 (신속한 해결책은 없다.)
- 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기 
- 빈틈없는 테스트
- 프로세스 격리
- 죽은 프로세스의 재시작 허용
- 프로덕션 환경에서 시스템 동작의 측정
- 모니터링
- 분석하기



## 인적 오류 

- 오류의 가능성을 최소화하는 방향으로 시스템 설계

*인터페이스가 지나치게 제한적이라서 제한된 인터페이스 피해 작업하도록 하면 안됨
- 비프로덕션 샌드박스 제공 

*샌드박스 : IT 에서 안전하게 격리된 실행 환경을 말함 모래상자처럼 외부와 차단된 공간에서 자유롭게 실험할 수 있는 곳 

- 단위 테스트에서부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트할것 
- 인적 오류를 빠르고 쉽게 복구할 수 있게 할것, 설정 변경 내역을 빠르게 롤백하고 새로운 코드를 서서히 롤아웃 하게 만들고 데이터 재계산 도구 제공 
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련 

비용을 줄여야 하는 시점을 매우 잘 알고 있어야 한다. 


# 확장성

성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가 
확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어 
확장성을 고민한다는 것은 시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?, 추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까같은 질문을 고려하는 것


1. 부하 기술하기 

현재 시스템의 현재 부하를 간결하게 기술해야 부하 성장 질문을 논의할 수 있다.
부하는 부하 매개변수(load paramter) 라 부르는 몇 개의 숫자로 나타낼 수 있다. 
부하 매개변수로 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자(active user), 캐시 적중률 등이 될 수 있다. 


   
*트위터의 확작성 문제 : 주로 트윗 양이 아닌 팬 아웃때문 (fan-out) 
*fan-out : 다른 게이트의 출력에 배속된 논리 게이트 입력의 수 / 출력은 배속된 모든 입력을 구동하기 위한 충분한 전류를 공급해야 한다.
트랜잭션 처리 시스템에서 하나의 수신 요청을 처리하는 데 필요한 다른 서비스의 요청 수를 설명하기 위해 팬 아웃을 사용 


*팔로우한 사람의 트윗 조회 구현 방법 2가지 
 1. 트윗 작성은 간단히 새로운 트윗을 트윗 전역 컬렉션에 삽입 -> 사용자가 자신의 홈 타임라인을 요청하면 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬해서 합치기 
 2. 각 수신사용자용 트윗 우편함처럼 개별 사용자의 홈 타임라인 캐시 유지 -> 사용자가 트윗을 작성하면 해당 사용자를 팔로우하는 사람을 모두 찾아 팔로워 각자의 홈 타임라인 캐시에 새로운 트윗 삽입
홈 타임라인의 읽기 요청은 요청 결과를 미리 계산했기 때문에 비용이 저렴하다. 

- 쓰기 시점에 더 많은 일을 하고, 읽기 시점에 적은 일을 하는 것이 바람직하다. 
- 2번의 문제는 트윗 작성이 많은 부가 작업을 필요로 한다는점
- 사용자당 팔로워의 분포는 팬아웃 부하를 결정하기 때문에 확장성을 논의할 때 핵심 부하 매개변수가 된다. 
- 혼합형으로 사용 : 대부분 사용자의 트윗은 계속해서 사람들이 작성할 때 홈 타임라인에 펼쳐지지만 팔로워 수가 매우 많은 소수 사용자는 팬 아웃에서 제외된다. 


2. 성능 기술하기

시스템 부하 기술해보기

a. 부하 매개변수를 증가시키고 시스템 자원(cpu, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까? 
b. 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까? 


Hadoop : 일괄 처리 시스템은 보통 처리량이 중요하다. 
*처리량(throughput) : 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간  
온라인 시스템에서 더 중요한 사항은 서비스 응답시간(response time) : 즉 클라이언트가 요청을 보내고 응답을 받는 사이의 시간 


다양한 요청을 다루는 시스템에서 응답 시간은 많이 변하기 때문에 응답 시간은 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야 한다.


특이값 : 모든 요청에 다양한 시간이 걸린다. 꽤나 오래걸리는 값이 생기기도 하는데 
여러가지 원인이 있을 수 있다. 
백그라운드 프로세스의 컨택스트 스위치, 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 휴지(garbage collection pause), 디스크에서 읽기를 강제하는 페이지 폴트 (page fault)
, 서버 랙의 기계적인 진동 등 여러가지 원인 

- 사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 중앙값이 좋은 지표이다. 



큐 대기 지연(queueing delay) : 높은 백분위에서 응답 시간의 상당 부분 차지 
선두 차단 (head-of-line blocking) : 서버에서 후속 요청이 빠르게 처리되더라도 이전 요청이 완료되길 기다리는 시간 때문에 클라이언트는 전체적으로 응답 시간이 느리다고 생각


시스템의 확장성을 테스트하려고 인위적으로 부하를 생성하는 경우 부하 생성 클라이언트는 응답 시간과 독립적으로 요청을 지속적으로 보내야한다.


## 부하 대응 접근 방식
- 부하 매개변수가 어느 정도 증가하더라도 좋은 성능을 유지하려면 어떻게 해야 할까? 

1. 용량 확장 (Scaling up : 수직 확장 vertical scaling) : 좀 더 좋은 성능의 장비로 확장 
2. 규모 확장 (Scaling out, 수평 확장 horizontal scaling) : 다수의 낮은 사양 장비에 부하를 분산 
*다수의 낮은 사양 장비에 부하를 분산하는 아키텍처를 비공유 아키텍처라고 부른다. 

다수의 장비에 상태 비저장(stateless) 서비스를 배포하는 일은 상당히 간단하다. 
하지만 단일 노드에 상태 유지(stateful) 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가적으로 발생한다. 
-> 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 고가용성 요구가 있을 때까지 단일 노드에 데이터베이스를 유지하는것(용량 확장)이 최근까지의 통념이다. 

- 아키텍처를 결정하는 요소는 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등이 있다. 


## 유지 보수성
- 운용성 (operability) : 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들기.
- 단순성 (simplicity) : 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들기
복잡도가 늘어나는 예시 : 상태 공간의 급증, 모듈 간 강한 커플링, 복잡한 의존성, 일관성 없는 명명과 용어, 성능 문제 해결을 목표로 한 해킹, 임시 방편 문제 해결
우발적 복잡도를 제거하기 위한 최상의 도구는 추상화이다. 
*좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다. 
*고수준 프로그래밍 언어는 기계 언어, cpu 레지스터, 시스템 호출을 숨긴 추상화다. 
- 발전성 (evolvability) : 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 할 것-> 요구사항 변경같은 예기치 않은 사용 사례를 적용하기 쉽게 된다.
유연성(extensibility), 수정 가능성(modifiability), 적응성(plasticity)
























































