애플리케이션 기능을 변경하려면 저장하는 데이터 변경 필요
관계형 데이터베이스는 일반적으로 데이터베이스의 모든 데이터가 하나의 스키마를 따른다고 가정

순회식 업그레이드 (rolling upgrade / 단계적 롤아웃 staged rollout) : 서버 측 애플리케이션에서는 한 번에 몇 개의 노드에 새 버전을 배포하고 새로운 버전이 원활하게 실행되는지 확인한 다음
서서히 모든 노드에서 실행되게 하는것 -> 서비스 정지 시간 없이 새로운 버전 배포 가능

양방향 호환성 유지 필요
- 하위 호환성 : 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 상위 호환성 : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.
*상위 호환성이 예전 버전의 코드

JSON, XML, 프로토콜 버퍼(Protocol Buffers), 스리프트 (Thrift), 아브로(Avro)



## 데이터 부호화 형식

- 메모리에 객체(object), 구조체(struct), 목록(list), 배열(array), 해시 테이블(hash table), 트리(tree) 등으로 데이터가 유지된다.
이런 데이터 구조는 CPU 에서 효율적으로 접근하고 조작할 수 있게 최적화된다.
데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 바이트열(JSON 문서) 의 형태로 부호화해야 한다.
포인터는 다른 프로세스가 이해할 수 없으므로 이 일련의 바이트열은 보통 메모리에서 사용하는 데이터 구조와는 다르다.


일종의 전환이 필요
- 인메모리 표현에서 바이트열로의 전환을 부호화(직렬화나 마샬링) 라고 하며 그 반대를 복호화(파싱, 역직렬화, 언마샬링) 라고 한다.


## JSON 과 XML, 이진 변형
- 수의 부호화는 어렵다. XML 과 CSV 에서는 수와 숫자(digit) 로 구성된 문자열을 구분할 수 없다. json 은 문자열과 수 구분 가능 정수와 부동소수점 수 구별하지 않고 정밀도 저장하지 않는다.


## 다양한 라이브러리와 부호화 형식

# 언어별 형식

자바 : java.io.Serializable
루비 : Marshal
파이썬 : pickle

# 문제점
- 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기가 어렵다. 현재 프로그래밍언어로만 코드를 작성하여 다른 시스템과 통합이 방해된다.
- 보안 취약점 : 임의의 객체를 역직렬화하면서 발생하는 원격 코드 실행(RCE) 위험
- 직렬화(Serialization) : 메모리 객체 바이트 배열 또는 문자열로 바꾸는 과정 / 저장하거나 전송하기 위해 필요
- 역직렬화(Deserialization) : 직렬화된 데이터를 다시 객체로 복원하는 과정 -> 이때 시스템은 어떤 클래스의 객체인지 알아야 한다.
    - 역직렬화 과정에서 입력으로 들어온 바이트열이 어떤 클래스의 객체인지 정보가 포함되고, 역직렬화 라이브러리는 그 정보를 기반으로 해당 클래스를 자동으로 로딩하고 인스턴스 생성
    -> 공격자가 조작한 바이트열을 넣으면 공격자가 원하는 임의의 클래스를 생성할 수 있다.
    - 방어 방법
        - 임의 클래스 로딩을 허용하지 않는 역직렬화 사용
            java -> Jackson 또는 Gson 같은 타입 제한된 JSON 바인딩 방식
        - 역직렬화 입력값을 외부에서 받지 않는다.
        - 허용된 클래스 목록(whitelist) 만 역직렬화
- 효율성의 문제


# 이진 부호화

- JSON, XML 데이터 모델은 데이터타입 셋을 변경하지 않고 유지하였고, 스키마를 지정하지 않았다. 따라서 부호화된 데이터 안에 모든 객체의 필드 이름을 포함해야 했다.



# 데이터 플로 모드

데이터플로 :
프로세스간 데이터를 전달하는 보편적인 방법
1. 데이터 베이스

데이터베이스에 기록하는 프로세스는 데이터를 부호화하고 데이터베이스에서 읽는 프로세스는 데이터를 복호화
- 하위 호환성 필요
- 스키마 발전은 기본 저장소가 여러 가지 버전의 스키마로 부호화된 레코드를 포함해도 전체 데이터베이스가 단일 스키마로 부호화된 것처럼 보이게 한다.
    이전 버전의 데이터 구조를 최신 스키마에 맞게 자동 변환해주는 기술
    기술 : Apache Avro, Protobuf, Thrift, Parquet, ORC, Kafka Schema Registry
- 데이터 덤프는 한 번에 기록하고 이후에는 변하지 않으므로 아브로 객체 컨테이너 파일과 같은 형식이 적합하다.
    - 아브로 객체 컨테이너 파일(Avro Object Container File) : 레코드 데이터 + 스키마 + 메타데이터를 하나의 파일 안에 함께 저장하는 Avro 의 파일 포맷
- 서비스를 통한 데이터플로: REST 와 RPC
    1. 클라이언트, 서버 역할
    웹 브라우저 내에서 수행되는 클라이언트측 자바스크림트 애플리케이션은 XMLHttpRequest 를 사용해 HTTP 클라이언트가 될 수 있다. (ajax 기술)

    2. 서비스 지향 설계(service-oriented architecture, SOA) : 하나의 서비스가 다른 서비스의 일부 기능이나 데이터가 필요하다면 새핟 서비스에 요청을 보낸다. -> 마이크로서비스 설계(microservices architecture)
    - 서비스 지향 및 마이크로서비스 아키텍처의 핵심 설계 목표는 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것

    3. Rest SOAP
        3-1. Rest 는 프로토콜이 아니라 http 의 원칙을 톧개로 한 설계 철학
        url 을 사용해 리소스를 식별하고 캐시 제어, 인증, 콘텐츠 유형 협상에 http 기능을 사용한다.
        RESTful : Rest 원칙에 따라 설계된 API
        3-2. SOAP
        SOAP 는 네트워크 API 요청을 위한 XML 기반 프로토콜
        - SOAP 웹 서비스의 API 는 웹 서비스 기술 언어(Web Services Description Language)또는 WSDL 이라고 부르는 XML 기반 언어를 사용해 기술

- 원격 프로시저 호출(RPC) 문제
    - 원격 프로시저 호출(remote procedure call, RPC) : 프로세스 간 네트워크 통신을 프로그래밍 언어의 프로시저 호출 추상화로 숨기는 것
    RPC 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해준다. (위치 투명성)
    1. Location Transparency (위치 투명성)
    2. Marshalling (직렬화) : 함수 인자를 네트워크용 데이터로 변환
    3. stub : 가짜 함수 껍데기
        3-1. Client Stub : 함수 호출을 네트워크 요청으로 바꿈
        3-2. Server Stub : 요청을 진짜 함수 호출로 바꿈
    - 결함 (로컬함수처럼 보이나 로컬함수가 아니기에 발생할 수 있는 이슈)
        - 로컬 함수 호출은 예측 가능하지만 네트워크 요청은 예측이 어렵다.
        - 실패한 네트워크 요청을 다시 시도할 때 요청이 실제로는 처리되고 응답만 유실될 수 있다. -> 프로토콜에 중복 제거 기법(멱등성) 을 적용하지 않으면 재시도 작업이 여러번 시도되는 문제가 있을 수 있다.
        - 실행시간이 다양하다.
        - 매개변수의 크기가 클 수 있음


2. 서비스 호출
3. 비동기 메시지 전달을 통해


# 분산 데이터

- 장비간 분산된 데이터베이스를 필요로 하는 이유
1. 확장성
데이터 볼륨, 읽기 부하, 쓰기 부하가 단일 장비에서 다룰 수 있는 양보다 커지면 부하를 여러 장비로 분배

2. 내결함성/고가용성
장비 하나(또는 여러 장비나 네트워크, 전체 데이터센터)가 죽더라도 애플리케이션이 계속 동작해야 한다면 여러 장비를 사용해 중복성을 제공할 수 있다.

3. 지연시간
사용자들이 전세계에 있다면 지리적으로 가까운곳의 데이터 센터 이용 가능

## 고부하로 확장
- 수직 확장이나 용량 확장가능
- 공유 메모리 아키텍처(shared-memory architecture) : 여러개의 CPU, 많은 메모리 칩, 많은 디스크를 하나의 운영체제로 함께 결함하여 빠른 상호 연결로 모든 CPU가 메모리나 디스크의 모든 부분에 접근할 수 있다.
- 공유 메모리 접근방식으로 확장한다고 하더라도 2배의 크기의 장비가 두배의 부하 처리할 수 있는것은 아니다. (병목현상 존재)
- 핫 스왑 : 장비를 중단시키지 않고 디스크, 메모리 모듈, CPU 교체 가능
- 공유 디스크 아키텍처 : 독립적인 CPU 와 RAM 을 탑재한 여러 장비를 사용하지만 데이터 저장은 장비 간 공유하는 디스크 배열에 한다.


## 비공유 아키텍처 (shared-nothing) -> 수평 확장, 규모 확장
- 노드 : 데이터베이스 소프트웨어를 수행하는 각 장비나 가상 장비
- 각 노드는 CPU, RAM, 디스크를 독립적으로 사용
노드 간 코디네이션은 일반적인 네트워크를 사용해 소프트웨어 수준에서 수행한다.
    - 각 노드는 독립적 (하드웨어 공유 없음), 노드들이 협력하려면 조율 필요, 네트워크 메시지(이더넷, TCP/IP) 등으로 조율


## 복제 대 파티셔닝
- 복제
같은 데이터의 복사본을 잠재적으로 다른 위치에 있는 여러 노드에 유지 복제는 중복성 제공

- 파티셔닝
큰 데이터베이스를 파티션이라는 작은 서브넷으로 나누고 각 파티션은 각기 다른 노드에 할당 (샤딩)





















