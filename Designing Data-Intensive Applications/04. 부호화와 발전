애플리케이션 기능을 변경하려면 저장하는 데이터 변경 필요
관계형 데이터베이스는 일반적으로 데이터베이스의 모든 데이터가 하나의 스키마를 따른다고 가정

순회식 업그레이드 (rolling upgrade / 단계적 롤아웃 staged rollout) : 서버 측 애플리케이션에서는 한 번에 몇 개의 노드에 새 버전을 배포하고 새로운 버전이 원활하게 실행되는지 확인한 다음
서서히 모든 노드에서 실행되게 하는것 -> 서비스 정지 시간 없이 새로운 버전 배포 가능

양방향 호환성 유지 필요
- 하위 호환성 : 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 상위 호환성 : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.
*상위 호환성이 예전 버전의 코드

JSON, XML, 프로토콜 버퍼(Protocol Buffers), 스리프트 (Thrift), 아브로(Avro)



## 데이터 부호화 형식

- 메모리에 객체(object), 구조체(struct), 목록(list), 배열(array), 해시 테이블(hash table), 트리(tree) 등으로 데이터가 유지된다.
이런 데이터 구조는 CPU 에서 효율적으로 접근하고 조작할 수 있게 최적화된다.
데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 바이트열(JSON 문서) 의 형태로 부호화해야 한다.
포인터는 다른 프로세스가 이해할 수 없으므로 이 일련의 바이트열은 보통 메모리에서 사용하는 데이터 구조와는 다르다.


일종의 전환이 필요
- 인메모리 표현에서 바이트열로의 전환을 부호화(직렬화나 마샬링) 라고 하며 그 반대를 복호화(파싱, 역직렬화, 언마샬링) 라고 한다.


## JSON 과 XML, 이진 변형
- 수의 부호화는 어렵다. XML 과 CSV 에서는 수와 숫자(digit) 로 구성된 문자열을 구분할 수 없다. json 은 문자열과 수 구분 가능 정수와 부동소수점 수 구별하지 않고 정밀도 저장하지 않는다.


## 다양한 라이브러리와 부호화 형식

# 언어별 형식

자바 : java.io.Serializable
루비 : Marshal
파이썬 : pickle

# 문제점
- 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기가 어렵다. 현재 프로그래밍언어로만 코드를 작성하여 다른 시스템과 통합이 방해된다.
- 보안 취약점 : 임의의 객체를 역직렬화하면서 발생하는 원격 코드 실행(RCE) 위험
- 직렬화(Serialization) : 메모리 객체 바이트 배열 또는 문자열로 바꾸는 과정 / 저장하거나 전송하기 위해 필요
- 역직렬화(Deserialization) : 직렬화된 데이터를 다시 객체로 복원하는 과정 -> 이때 시스템은 어떤 클래스의 객체인지 알아야 한다.
    - 역직렬화 과정에서 입력으로 들어온 바이트열이 어떤 클래스의 객체인지 정보가 포함되고, 역직렬화 라이브러리는 그 정보를 기반으로 해당 클래스를 자동으로 로딩하고 인스턴스 생성
    -> 공격자가 조작한 바이트열을 넣으면 공격자가 원하는 임의의 클래스를 생성할 수 있다.
    - 방어 방법
        - 임의 클래스 로딩을 허용하지 않는 역직렬화 사용
            java -> Jackson 또는 Gson 같은 타입 제한된 JSON 바인딩 방식
        - 역직렬화 입력값을 외부에서 받지 않는다.
        - 허용된 클래스 목록(whitelist) 만 역직렬화
- 효율성의 문제


# 이진 부호화

- JSON, XML 데이터 모델은 데이터타입 셋을 변경하지 않고 유지하였고, 스키마를 지정하지 않았다. 따라서 부호화된 데이터 안에 모든 객체의 필드 이름을 포함해야 했다.





