### 이벤트 -> 프론트 브로드 캐스트 흐름을 안전하게 생성



0. Redis Streams 
0-1. 장점
- 메시지 내구성 : 메시지가 Stream 에 저장되어, 클라이언트가 끊겼다가 다시 연결해도 소비 가능
- 멀티 인스턴스 지원 : Consumer Group 으로 여러 워커가 동시에 처리 가능
- 재시도 및 Ack : 메시지 처리 후 Ack 를 보내야 삭제 -> 실패 시 재처리 가능
- 백프레셔 관리 : Flux, Reactive 와 쉽게 통합 가능
- 단순 구현 : Redis 이미 사용 중이면 추가 인프라 부담 없음
- 순서 보장 : 메시지 순서가 보장되며, ID 기반 조회 가능
0-2. 단점
- Redis 서버 의존
- 영속화 제한 : 너무 오래 쌓으면 메모리, 디스크 부담
- Kafka 처럼 대규모 이벤트 처리에는 한계 
- PB 급 처리에는 적합하지 않음
- 복잡한 라우팅, 필터링은 불편 : Pub/Sub 처럼 topic 단순화는 쉽지만, 복잡한 stream processing 은 불편 
0-3. 사용 예시 
- 이메일 Polling -> 이벤트 스트림
- 실시간 알림/메시지 브로드 캐스트
- 멀티 서버 환경에서 상태 전파 
- Flux + Websocket 을 통한 양방향 실시간 통신 
- 


1. Apache Kafka 
1-1. 장점
- 고성능, 내구성 강함
- 멀티 컨슈머 그룹 지원
- 대용량 메시지 처리 가능
1-2. 단점
- 운영 난이도 높음
- 작은 프로젝트에는 과함
1-3. 예시 
- 이메일, 로그, 이벤트 소싱, 재시도, replay 필요 



2. RabbitMQ 
2-1. 장점
- AMQP 표준 지원
- Pub/Sub, Work Queue 등 다양한 패턴
- Ack 기반 안정성
2-2. 단점
- 메시지 저장량 제한
- Kafka 보다 대규모 처리엔 부담이 됨
2-3. 사용 케이스 : 트리거 이벤트 분배, WebSocket 브로드 캐스트 전단계 


3. Amazon SQS/ SNS
4. Google Pub, Sub 
5. NATS
5-1. 장점
- 경령/빠름
- Pub/Sub, Request/Reply, Queue 지원
5-2. 단점
- 메시지 내구성은 별도 설정 필요
5-3. 사용 케이스 : 초저지연 이벤트, 다중 마이크로 서비스 


6. Redis Pub/Sub
6-1. 장점 
- 간단, 구현 쉬움
- WebSocket 브로드캐스트와 궁합 좋음
6-2. 단점
- 메시지 손실 가능 (클라이언트 연결 안 돼있으면 사라짐)
- 멀티 인스턴스 확장성 한계
6-3. 사용 케이스
- 임시 실시간 알림
- 로그 브로드캐스트

7. In-memory/DB 기반 큐
- Redis List, PostgreSQL NOTIFY, RabbitMQ Lite
7-1. 장점
- 이미 있는 DB/Redis 활용
- 구현 단순 
7-2. 단점
- 확장성, 내구성 제한
7-3. 사용 케이스 : 소규모 프로젝트, 간단한 Polling -> Websocket 