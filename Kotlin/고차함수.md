 고차함수 : 람다를 인자로 받거나 반환하는 함수인 고차함수

코드 중복을 없애고 더 나은 추상화를 구축

인라인 함수

*람다 : 이름없는 함수, 익명 함수

8.1 고차함수 정의

- 고차함수 : 다른 함수를 인자로 받거나 함수를 반환하는 함수
- 코틀린에서는 람다나 함수 참조를 사용해 함수를 값으로 표현할 수 있다.
- 고차함수는 람다나 함수 참조를 인자로 넘길 수 있거나 람다나 함수 참조를 반환하는 함수다.

- 함수 타입
    - 람다를 인자로 받는 함수 정의하려면 먼저 람다 인자 타입 선언 방법을 알아야 한다.
    - 람다를 로컬 변수에 대입해 보기
        - val sum = {x: Int, y = Int → x + y}
        - val action = {println(43)}
        - (타입 추론)

      → 컴파일러가 sum, action 이 함수 타입이라는 것을 추론한다.

        - 구체적인 타입 선언을 추가해 본다.
    - val sum: (Int, Int) → Int = { x,y → x + y } : Int 타입의 파라미터를 2개 받아서 Int 값을 반환하는 함수
    - val action: () → Unit = {println(42)} : 아무 인자도 받지 않고 아무 값도 반환하지 않는 함수
    - 함수 타입 정의 방법 : 함수 파라미터의 타입을 괄호 안에 넣고, 그 뒤에 화살표 (→) 를 추가한 다음, 함수의 반환 타입을 지정하면 된다.  (Int, Int) → Unit


함수 타입정의

- Unit 타입은 의미 있는 값을 반환하지 않는 함수 반환 타입에  쓰는 특별한 타입
- 그냥 함수를 정의한다면 함수의 파라미터 목록 뒤에 오는 Unit 반환 타입 지정을 생략해도 되지만, 함수 타입을 선언할 때는 반환 타입을 반드시 명시해야 하기 때문에 Unit 을 빼먹으면 안된다.
- 변수 타입을 함수 타입으로 지정하면 함수 타입에 있는 파라미터로부터 람다의 파라미터를 유추가능하다. → 생략 가능 { x, y → x + y }, x,y 의 타입 생략 가능
- 함수 타입에서도 반환 타입을 널이 될 수 있는 타입으로 지정 가능
    - var canReturnNull: (Int, Int) → Int? = (x, y → null) : 널이 될 수 있는 반환 타입을 갖는 함수 타입을 선언
- 널이 될 수 있는 함수 타입 변수를 정의할 수도 있다. (널 가능성이 존재하는 함수)
    - var funOrNull: ((Int, Int) → Int)? = null  : 널이 될 수 있는 함수 타입
- 함수 타입에서 파라미터 이름을 지정할 수 있다.
    - fun function(url: String, callback: (code: Int, content String) → Unit)
        - function(url) {code, content → } : callback 변수의 content 이름을 동일하게 사용
        - function(url) {code, page → } : content 변수명대신 page 로 사용할 수 있다.
- 고차함수 정의하기

    ```sql
    fun twoAndThree(operation: (Int, Int) -> Int)  {
    	val result = operation(2,3) : 함수타입인 파라미터를 호출한다. 
    	println("The result is $result")
    }
    >> twoAndThree(a,b -> a + b)
    >> twoAndThree(a,b -> a * b) 
    
    ```

- filter 구현

fun String.filter(predicate: (Char) → Boolean): String

fun String.filter : 수신 객체 타입

predicate : 파라미터 이름

(Char) →  Boolean : 문자 타입을 파라미터로 받고 불리언 타입을 결과값으로 반환

filter 함수 구현

```jsx
fun String.filter(predicate: (Char) -> Boolean): String {
	val sb = StringBuilder() 
	for (index in 0 until length) {
		val element = get(index) {
			if(predicate(element)) sb.append(element) 
		}
		return sb.toString() 
	}
}
```

: filter 는 문자열의 각 문자를 술어(함수 파라미터)에 넘겨서 반환 값이 true 면 결과를 담는 StringBuilder 뒤에 그 문자를 추가한다.

8.1.3 자바에서 코틀린 함수 타입 사용

컴파일된 코드 안에서 함수 타입은 일반 인터페이스로 바뀐다.

함수 타입의 변수는 FunctionN 인터페이스를 구현하는 객체를 저장한다.

코틀린 표준 라이브러리는 함수 인자의 개수에 따라 Function0<R> (인자가 없는 함수), Function1<P1, R> (인자가 하나인 함수) 등의 인터페이스를 제공한다.

각 인터페이스에는 invoke 메서드 정의가 하나 들어 있다.

invoke 를 호출하면 함수를 실행할 수 있다.

invoke 메서드 본문에는 람다의 본문이 들어간다.

- 자바 8 람다를 넘기면 자동으로 함수 타입의 값으로 변한다.
- 자바 8 이하는 직접 FunctionN 인터페이스의 invoke 메서드를 구현하는 무명 클래스를 넘기면 된다.
- 반환 타입이 Unit 인 함수나 람다를 자바로 작성시 코틀린 Unit 타입에는 값이 존재하기 때문에 자바에서는 값을 명시적으로 반환해줘야 한다.

  (String) → Unit 처럼 반환 타입이 Unit 인 함수 타입의 파라미터 위치에 void 를 반환하는 자바 람다를 넘길 수 없다.

  ![Screenshot 2025-05-14 at 10.40.04 PM.png](attachment:2ee5f041-cfe1-43d6-8bc4-423f17e8c5f6:Screenshot_2025-05-14_at_10.40.04_PM.png)


8.1.4 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터

파라미터를 함수 타입으로 선언할 때도 디폴트 값을 정할 수 있다.

- 함수 타입 파라미터의 디폴트 값이 유용한 경우에 대한 예시

```jsx
fun <T> Collection<T>.joinToString(
	separator: String = ", ", 
	prefix: String = "", 
	postfix: String = "", 
	transform: (T) -> String = {it.toString()} : // transform 변수의 타입을 함수타입으로 만들고 람다를 디폴트 값으로 지정한다.
// T 제네릭 

): String {

	val result = StringBuilder(prefix) 
	
	for((index, element) in this.withIndex()) {
		if(index > 0) result.append(separator) 
		result.append(transform(element)) // transform 파라미터로 받은 함수를 호출한다. 
	
	}
	result.append(postfix) 
	return result.toString() 
}

// 호출하는 부분 
letters.joinToString() -> default 를 사용
letters.joinToString {it.toLowerCase()} : 람다를 인자로 전달 
letters.joinToString(separator = "! ", postfix = "! ", ... transform = {it.toUpperCase() } ))

```

- 널이 될 수 있는 함수 타입 파라미터를 사용하기

```jsx
fun <T> Collection<T>.joinToString(
separator: String = ", ", 
	prefix: String = "", 
	postfix: String = "", 
	transform: ((T) -> String) = null // 널이 될 수 있는 함수 타입의 파라미터를 선언한다. 
): String {
	val result = StringBuilder(prefix) 
	for ((index, element) in this.withIndex()) {
		if (index > 0) result.append(separator) 
		val str = transfor?.invoke(element) // invoke 는 함수를 실행시키는 인터페이스의 메서드 
			?: element.toString() // 엘비스 연산자를 사용해 람다를 인자로 받지 않은 경우를 처리한다. 
		result.append(str)
	}

result.append(postfix) 
return result.toString() 

} 

}
```

8.1.5 함수를 함수에서 반환

- 수는 적음

```jsx
enum Class Delivery {STANDARD, EXPEDITED}

class Order(val itemCount: Int) 

fun getShippingCostCalculator(delevery: Delivery) : (Order) -> Double { // 함수를 반환하는 함수를 선언한다. 
	if(delivery == Delivery.EXPEDITED) {
		return {order -> 6 + 2.1 * order.itemCount} 
	}
	return {order -> 1.2 * order.itemCount}
}

>>> val calculator = getShippingCostCalculator(Delivery.EXPEDITED)
calculator(Order(3)) 

```

→ 다른 함수를 반환하는 함수를 정의하려면 함수의 반환 타입으로 함수 타입을 지정해야 한다.

getShippingCostCalculator  함수는 Order 를 받아서 Double 로 반환하는 함수이다.

함수를 반환하려면 return 식에 람다나 멤버 참조나 함수 타입의 값을 계산하는 식 등을 넣으면 된다.

8.1.6 람다를 활용한 중복 제거

```kotlin
data class SiteVisit(
	val path: String, 
	val duration: Double, 
	val os: Os 
)

enum class OS {WINDOWS, LINUX, MAC, IOS, ANDROID}

val log = listOf(
	SiteVisit("/", 34.0, OS.WINDOWS), 
	SiteVisit("/", 22.0, OS.MAC), 
	SiteVisit("/login", 12.0, OS.WINDOWS), 
	SiteVisit("/signup", 8.0, OS.IOS), 
	SiteVisit("/", 16.3, OS.ANDROID),  
)

//average 함수 사용 OS.WINDOWS 사용평균 시간 구하기 

val averageWindowsDuration = 
log.filter {it.os == OS.WINDOWS } 
.map(SiteVisit::duration)
.average() // 23.0 

// 확장성 높게 작업하기
fun List<SiteVisit>.averageDurationFor(os: OS) = 
filter {it.os == os }.map(SiteVisit: duration).average()
// 자유롭게 구할 수 있음 
log.averageDurationFor(OS.WINDOWS)
log.averageDurationFor(OS.MAC)
 

fun List<SiteVisit>.averageDurationFor(predicate: (SiteVisit) -> Boolean) = 
filter(predicate).map(SiteVisit::duration).average() 

log.averageDurationFor {... it.os in setOf(OS.ANDROID, OS.IOS)}
>> 12.15

```

변수, 프로퍼티, 파라미터 등을 사용해 데이터의 중복을 없앨 수 있는 것처럼 람다를 사용하면 코드의 중복을 없앨 수 있다.

8.2 인라인 함수: 람다의 부가 비용 없애기

- 코틀린이 보통 람다를 무명 클래스로 컴파일하지만 그렇다고 람다 식을 사용할 때마다 새로운 클래스가 만들어지지는 않는다.

  람다가 변수를 포획하면 람다가 생성되는 시점마다 새로운 무명 클래스 객체가 생긴다 → 실행 시점에 무명 클래스 생성에 따른 부가 비용이 들기 때문에 람다를 사용하는 구현은 똑같은 작업을 수행하는 일반 함수를 사용한 구현보다 덜 효율적이다.

- 반복되는 코드를 별도의 라이브러리 함수로 빼내고, 컴파일러가 자바의 일반 명령문만큼 효율적인 코드를 생성할 수 있도록 inline 변경자를 함수에 붙이면 컴파일러는 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔치기 해준다.

8.2.1 인라이닝이 작동하는 방식

- 어떤 함수를 inline 으로 선언하면 그 함수의 본문이 인라인이 된다.
- 함수를 호출하는 코드를 함수를 호출하는 바이트코드 대신에 함수 본문을 번역한 바이트코드로 컴파일한다.

```kotlin
inline fun<T> synchronized(lock: Lock, action: () -> T): T {
	lock.lock()
	try {
	
		return action()
	}
	finally {
		lock.unlock()
	}

}

val 1 = Lock()
synchronized(1) 

```

- 위코드가 자바랑 다른 점은 Lock 인스턴스를 요구한다는 것
- 코틀린에는 아무타입의 파라미터를 받을 수 있는 synchronized 도 제공하고 있으나 동기화에 명시적인 락을 사용하면 더 신뢰할 수 있고 관리하기 쉬운 코드를 만들 수 있다.
- 인라인 함수라 컴파일 시 함수 호출이 제거되고 코드가 실제로 삽입되므로 최적화가 이뤄지고, 성능 손실 없이 자바의 동기화 방식과 똑같이 작동합니다.

8.2.2 인라인 함수의 한계

인라이닝을 하는 방식으로 인해 람다를 사용하는 모든 함수를 인라이닝할 수는 없다.

- 함수가 인라이닝될 때 그 함수에 인자로 전달된 람다 식의 본문은 결과 코드에 직접 들어갈 수 있다.
- 이렇게 되면 람다가 본문에 직접 펴쳐지기 떄문에 함수가 파라미터로 전달받은 람다를 본문에 사용하는 방식이 한정될 수 있다.
- 함수 본문에서 파라미터로 받은 람다를 호출하면 람다 본문으로 바꿀 수 있지만 변수에 저장하고 나중에 사용한다면 람다를 표현하는 객체가 존재해야 하기 때문에 인라이닝이 불가능하다.
- 그래서 `inline` 함수를 제대로 활용하려면 **람다를 변수에 저장하지 않고 즉시 실행해야** 한다.

예시

```kotlin
inline fun doSomething(action: () -> Unit) {
    action()
}
doSomething {
    println("Hi")
}
println("Hi") -> 실제로 실행되는 부분 
: 함수 호출 없이 바로 실행 코드가 들어가서 성능이 좋아진다. 

- 인라이닝 불가능 
inline fun store(action: () -> Unit) {
    val later = action // 람다 저장
    // 나중에 실행하려고 보관
}
```

- 인라이닝이 불가능한 이유 (Illegal usage of inline-parameter)

  이런 경우에는 `action()` 자리에 람다 내용을 복사할 수가 없다.

  왜냐면 **실행 시점이 정해져 있지 않고, 실행 위치도 명확하지 않기 때문이다.**

  또, **람다 자체를 변수로 저장했으니, 이건 객체로 존재해야 한다.**


```kotlin
fun <T, R> Sequence<T>.map(transform: (T) -> R) : Sequence<R> {
	return TransformingSequnce(this, transform) 
}
```

- map 함수는 transform 파라미터로 전달받은 함수 값을 호출하지 않는 대신 클래스의 생성자에게 그 함수 값을 넘긴다.
- 생성자는 전달 받은 람다를 프로퍼티로 저장한다.
- 따라서 transform 인자를 일반적인 함수표현 (인라이닝 하지 않은) 으로 만들어야만 한다.

- 인라이닝 하면 안되는 람다를 파라미터로 받는다면 noinline 변경자를 파라미터 이름 앞에 붙여서 인라이닝을 금지할 수 있다.

    ```kotlin
    inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {}
    ```


8.3.4 컬렉션 연산 인라이닝

- 코틀린의 filter 함수는 인라인 함수이다.
- filter 함수의 바이트코드는 그 함수에 전달된 람다 본문의 바이트코드와 함께 filter 를 호출한 위치에 들어간다. → 따라서 filter 를 쓸떄와 일반함수를 쓸때 바이트코드는 거의 같다.
- 컬렉션에 대해 안전한게 사용할 수 있는 코틀린
- filter, map 을 두개를 사용했을때

    ```kotlin
    people.filter {it.age > 30}
    			.map(Person::name) // 
    ```

    - filter, map 은 인라인 함수이다.
    - filter 에서 걸러진 데이터로 중간 리스트를 생성한다.
    - 중간 리스트 부가비용이 커질 수 있다.
    - asSequence 를 통해 리스트 대신 시퀀스를 사용하여 중간 리스트로 인한 부가 비용을 줄일 수 있다.
    - 시퀀스는 람다를 인라인 하지 않는다. (람다를 저장해야 하기 때문에)
    - 각 중간 시퀀스는 람다를 필드에 저장하는 객체로 표현되며7 최종 연산은 중간 시퀀스에 있는 여러 람다를 연쇄 호출한다.
    - 지연 계산을 통해 성능을 향상시키려는 이유로 모든 컬렉션 연산에 asSequence 를 붙이면 안된다.
    - 시퀀스 연산에서 람다가 인라이닝 되지 않기 때문에 크기가 작은 컬렉션은 오히려 일반 컬렉션 연산보다 더 성능이 나을 수도 있다. → 시퀀스를 통해 성능을 향상시킬 수 있는 경우는 컬렉션 크기가 큰 경우


8.2.4 함수를 인라인으로 선언해야 하는 경우

- inline 키워드를 사용하면 람다를 인자로 받는 함수만 성능이 좋아짐 (전부 다 붙여야 하는 것이 아님)
- JVM 은 코드 실행을 분석해서 가장 이익이 되는 방향으로 호출을 인라이닝 해줌
- 람다를 인자로 받는 함수 인라이닝 했을때
    - 인라이닝을 통해 부가 비용 줄일 수 있다. 호출비용도 줄이고 람다를 표현하는 클래스, 람다 인스턴스에 해당하는 객체를 만들 필요가 없다.
    - JVM 이 람다를 인라이닝 해주기 어렵다.
    - 코틀린 표준 라이브러리가 제공하는 Inline 함수를 보면 모두 크기가 작다.


8.2.5 자원 관리를 위해 인라인된 람다 사용

- 람다로 중복을 없앨 수 있는 일반적인 패턴을 알아보자
- 어떤 작업을 하기 전에 자원(파일, 락, 데이터베이스 트랜젝션)을 획득하고, 작업을 마친 후 자원을 해제하는 자원관리 패턴을 사용하면 된다.
- try catch
- withLock
    - 락을 잠근 다음에 주어진 동작을 실행하는 것
- try with resource
    - 코틀린의 use 로 사용 가능
    - 닫을 수 있는 자원에 대한 확장 함수

8.3 고차 함수 안에서 흐름 제어

return 문제를 알아보자

8.3.1 람다 안의 return 문: 람다를 둘러싼 함수로부터 반환

- for (person in people) vs people.forEach {람다식}
    - 람다 안에서 return 을 사용하면 람다로부터만 반환되는 게 아니라 그 람다를 호출하는 함수가 실행을 끝나고 반환된다. → 자신을 둘러싸고 있는 블록보다 더 바깥에 있는 다른 블록을 반환하게 만드는 return 문을 넌로컬 return 이라고 부른다.
- return 이 바깥쪽 함수를 반환시킬 수 있는 때는 람다를 인자로 받는 함수가 인라인 함수인 경우뿐
- 인라이닝이 되지 않는 함수에 전달되는 람다 안에서 return 을 사용할 수는 없다.
- 인라이닝되지 않는 함수는 람다를 변수에 저장할 수 있고 바깥쪽부터 반환된 뒤에 저장해 둔 람다가 호출될 수도 있기 때문에 시점이 맞지 않게 된다.

8.3.2 람다로부터 반환 : 레이블을 사용한 return

- 람다식에서도 로컬 return 을 사용할 수 있다.
- 람다 안에서 로컬 return 은 for 루프의 break 와 비슷한 역할을 한다.
- 로컬 return 은 람다의 실행을 끝내고 람다를 호출했던 코드의 실행을 이어간다.
- 로컬 return 과 넌로컬 return 구분을 위해 label dmf tkdydgksek.



    ```kotlin
    people.forEach label@ {
    	.....
    	return@label
    }
    ```


8.3.3 무명함수 : 기본적으로 로컬 return

- 무명함수는 코드 블록을 함수에 넘길 때 사용할 수 있다. \
- 무명 함수 안에서 레이블이 붙지 않은 return 식은 무명 함수 자체를 반환시킬 뿐 무명 함수를 둘러싼 다른 함수를 반환시키지 않는다.
- 무명함수는 fun 을 사용해 정의되므로 그 함수 자신이 바로 가장 안쪽에 있는 fun 으로 정의된 함수다.
- 무명 함수 본문의 return 은 그 무명 함수를 반환시키고, 무명 함수 밖의 다른 함수를 반환시키지 않는다.