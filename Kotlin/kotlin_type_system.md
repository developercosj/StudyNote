
# 6.1 널 가능성 

## 6.1.1 널이 될 수 있는 타입 
- 프로퍼티나 변수에 null 허용을 명시할 수 있음 
- 타입 뒤에 ? 등을 붙여서 null 참조 저장 가능 
- 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다.

    - val x: String? = null (o)
    - val x: String = null (x) 
- null 이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.
## 6.1.2 타입의 의미
- nullpointerException 방지 도구
  - anotation 이용 (@Nullable, @NotNull)
  - Java 8 에 도입된 Optional 이용
    - null 을 감싸는 특별한 래퍼 타입 활용 
    - 어떤 값이 정의되거나 정의되지 않을 수 있음을 표현한 타입 
    - 단점으로는 코드가 지저분해지고 래퍼가 추가되어 실행 시점에 성능 저하 가능 
    - 코드상에서 사용하는 Optional 은 JDK 메서드나 안드로이드 프레임워크, 서드파티 라이브러리 등에 반환되는 null 처리해야함
  

## 6.1.3 안전한 호출 연산자: ?. 

- ?. : 코틀린에서 사용하는 안전한 호출 연산자 
  - 호출하려는 값이 null 이 아니라면 ?.은 일반 메서드 호출처럼 작동한다. 
  - 호출하려는 값이 null 이면 이 호출은 무시되고 null 이 결과값이 된다. 
  - 객체 그래프에서 널이 될 수 있는 중간 객체가 여럿 있다면 한 식에서 안전한 호출 연쇄해서 사용 가능 

## 6.1.4 엘비스 연산자: ?: 
- null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자가 엘비스 연산자 
- fun foo(s: SString?) {
  val t: String = s ?: ""
}
  - 좌항 값이 널이 아니면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다.
- fun Person.countryName() = company?.address?.country ?: "Unkown"
  - 객체 그래프 표현이 쉽다. 
- 코틀린에서는 Return 이나 throw 등의 연산도 식이기 떄문에 엘비스 연산자의 우항에 return throw 등의 연산도 넣을 수 있다. 
  - 함수의 전제 조건을 검사하는 경우 특히 유용하다. 


## 6.1.5 안전한 캐스트: as? 
- 자바 타입 캐스트와 마찬가지로 대상 값을 as로 지정한 타입으로 바꿀 수 없으면 ClassCastException 이 발생한다. 
- is 를 사용해서 as 로 타입을 변환하기 전에 검사하는 것도 가능하다. 
- as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다. 
- ? 로인해 지정한 값으로 변경할 수 없다면 null 을 반환
- 안전한 연산자를 사용해 equals 구현하기 
  class Person(val firstName: String, val lastName: String) {
    override fun equals(o:Any?): Boolean {
      val otherPersion = o as? Person ?: return false // 타입이 서로 일치하지 않으면 false 반환
      return otherPerson.firstName == firstName && otherPerson.lastName == lastName // 안전한 캐스트를 하고 나면 otherPersion 이 Person 타입으로 스마트 캐스트 된다. 
  }
  
  ...생략 
    
  } 
  - 파라미터로 받은 값이 원하는 타입인지 쉽게 검사하고 캐스트 할 수 있다. 
  - 한 식에서 해결할 수 있도록 간결화할 수 있다. 


## 6.1.6 널 아님 단언: !!
- 널이 될 수 있는 타입의 값을 다룰때 느낌표를 이중으로 사용하여 널이 될 수 없음을 표현할 수 있다. 
- !! 를 여러번 쓸때 어떤 곳에서 예외가 발생했는지 알기 힘들다. 
  - person.company!!.address!!.country -> 이런식으로 작성하는 것을 지양하자 


## 6.1.7 let 함수
- let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다. 
- fun sendEmailTo(email: String) ... 
  - 이런 함수에서 email 값에 null 허용되는 인자를 넘길 수는 없다. 
  - 따라서 넘기기 전에 주어진 값이 널인지 검사해야 한다. 
  - let 함수를 사용하여 자신의 수신 객체를 인자로 전달받은 람다에게 넘길 수 있다. 
  - 따라서 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 값으로 바꿔서 람다에 전달할 수 있다. 
  - let 함수는 널이 아닌 경우에만 호출된다.  

## 6.1.8 나중에 초기화할 프로퍼티 lateinit
  - 객체 인스턴스를 일단 생성한 다음 나중에 초기화하는 경우가 있다. 
  - 코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메서드 안에서 초기화할 수는 없다.
  - 코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한다. 
  - 초기화 값을 제공할 수 없으면 널이 될 수 있는 타입을 사용할 수밖에 없다. -> 단점은 널검사 또는 !! 를 써야하는 불편함 존재 
  - 나중에 초기화하는 프로퍼티는 항상 var여야 한다. 
  - val 은 final 필드 
  - lateinit 필드가 초기화 되기전에 접근하면 예외가 발생한다.  

## 6.1.9 널이 될 수 있는 타입 확장 
  - 디스패치 : 객체지향 언어에서 객체의 동적 타입에 따라 적절한 메서드를 호출해주는 방식을 동적 디스패치라 부른다. 컴파일러가 컴파일 시점에 어떤 메서드가 호출될지 결정해서 코드를 생성하는 방식을 직접 디스패치라고 한다. 
  - 확장함수 메서드에서 널을 검사할 수 있다. 
  - 예) 코틀린 라이버르러 String 확장하여 정의된 isNullOrEmpty, isNullOrBlank 메서드 
    * isBlank 는 널이 아닌 문자열 타입의 값에 대해서만 호출할 수 있다. 

## 6.1.10 타입 파라미터의 널 가능성
  - 코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다. 
  - 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 ? 가 없더라도 널이 될 수 있는 타입이다. 

  fun <T> printHashCode(t:T) { // t는 ?가 붙지 않아도 null 을 받을 수 있음 
    println(t?.hashCode()) // t 는 널이 될 수 있기 떄문에 안전한 호출을 써야 한다. 
  }
  printHashCode(null)
null 

  - 널이 될 수 없는 것을 명확히 하기 위해서는 타입 상한을 지정해야 한다. 
    - fun <T: Any> printHashCode(t: T) { -> t는 널이 될 수 없는 타입 
      println(t.hashCode())
    }

## 6.1.11 널 가능성과 자바 
  - 코틀린과 자바의 상호운용성 
  - 자바 @Nullable String 과 코틀린의 String? 이 같다. 
  - 자바의 @NotNull String 은 코틀린의 String 과 같다. 
  - 플랫폼 타입
    - 코틀린이 널 관련 정보를 알 수 없는 타입 
    - 플랫폼 타입에 대해 수행하는 모든 연산에 대한 책임은 개발자에게 있다. 즉 컴파일러는 모든 연산을 허용해준다. 
    - 따라서 플랫폼 타입을 사용할때는 NullpointerException 을 염두해 둬야 한다. 
    - 자바 타입은 코틀린에서 플랫폼 타입으로 표시되며 널이 될 수 있는 타입이나 널이 될 수 없는 타입 모두로 사용할 수 있다. 
    - 코틀린에서 플랫폼 타입을 선언할 수는 없고 자바 코드에서 가져온 타입만 플랫폼 타입이 된다. 
    - String! : 코틀린 컴파일러가 하는 이 표기는 String! 타입의 널 가능성에 대해 아무 정보도 없다는 뜻
    - 자바타입을 코틀린에 가져와 사용할 떄 주의해야 한다. 
  - 상속 
    - 코틀린에서 자바 메서드를 오버라이드할 때 그 메서드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정이 필요
      (자바는 플랫폼 타입이기 때문에)
    - 자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 것이 필요
    class StringPrinter : StringProcessor {
      override fun process(value: String) {
        println(value)
      }
    }
    class NullableStringPrinter : StringProcesspr {
      override fun process(value: String?) {
        if (value != null) {
          println(value)
        }
      }
    }

  


