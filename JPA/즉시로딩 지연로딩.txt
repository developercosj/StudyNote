지연 로딩
    - 사용법 : @ManyToOne(fetch = FetchType.LAZY)
    - 설정한 객체는 프록시로 가져오게 됨
    - 객체를 실제 사용하는(메서드사용) 시점에 프록시 객체가 실행됨
    - 지연로딩을 사용하면 쿼리가 2번나가게 됨 ( 객체 A, 프록시 객체 B 따로) -> 성능상 손해를 보게됨
    - @ManyToOne은 모두 Lazy 설정 필요

즉시 로딩
    - EAGER 를 사용하여 함께 조회가 가능하다.
        : @ManyToOne(fetch = FetchType.EAGER) : 객체 A, B 가 모두 조인해서 가져옴
    - 프록시 X , 실제 객체
    - 초기화가 된것
    - 방법
        - join 으로 가져옴
        - em.find 에서 쿼리를 두번 구현 가능
    - 대부분 한번에 조인쿼리로 가지고 오려고함 (EAGER 사용) -> 실무에서는 즉시로딩사용 하지 않는 것이 좋다.
        - 즉시 로딩을 적용하면 예상 못한 SQL 발생 가능
        - 조인으로 많은 테이블을 조인하게 되면 문제가 많다.
        - 즉시로딩은 JPQL 에서 N+1 문제를 일으킨다.
        - @ManyToOne, @OneToOne은 기본이 즉시로딩이기 때문에 LAZY 로 설정 필요
    - JPA 내부적으로 작동하는 것과 달리 JPQL 이 SQL 로 번역이 되면서 EAGER로 설정해도 JPQL이 먼저 실행되고 EAGER 가 설정되어 있기 때문에 모든 객체를 가지고 있어야 하기 때문에
      SQL 이 또 다시 작동


