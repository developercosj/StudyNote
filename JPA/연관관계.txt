- 방향 : 단방향, 양방향
- 다중성 : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)
- 연관관계의 주인(Owner) : 객체 양방향 연관관계
- 객체와 테이블 연관관계
    - 객체 연관관계 : 2개
        *객체의 양방향 관계는 사실 단방향 2개라고 할 수 있다.
        회원 -> 팀 연관관계 1개 (단방향)
        팀 -> 회원 연관관계 1개 (단방향)
    - 테이블 연관관계 : 1개
        회원 <-> 팀의 연관관계 1개(무방향)
        FK 하나로 (join 이 가능하니까) 두 테이블의 연관관계 관리가 가능
- 연관관계의 주인(Owner) 정하기
    - 양방향 매핑을 할때 각 A,B 객체에 B,A 객체가 서로 포함되어 있는 연관관계일때 DB 테이블애서는 FK만 있으면 서로 관계를 가져올 수 있다(JOIN을 통해)
    - 하지만 객체의 위치에서는 A 객체 B 객체 중에 어떤 것을 바꿔야 -> FK의 키를 update 할 수 있는지에 대한 결정이 필요하다.
    - 객체의 두 관계중 하나를 연관관계의 주인으로 지정하는 것이 필요하다.
    - 연관관계의 주인만 외래키를 관리할 수 있다 (등록, 수정)
    - 주인이 아닌쪽은 읽기만 가능하다.
    - 주인은 mappedBy 속성 사용이 불가하며 주인이 아니면 mappedBy속성으로 주인을 지정해야 한다.
    - 주인으로 지정하는 객체
        - 외래키가 있는 곳으로 주인을 정할것(성능이슈등 다양한 이유로)
        - 1:N 일때 N 일때 연관관계의 주인이 된다.
        - 양방향 매핑시 연관과계의 주인에 값을 입력해야 한다.
          mappedBy 속성을 사용한 객체는 주인이 아니기때문에 update 등이 불가하고 읽기만 가능하다. 따라서 값을 넣어도 DB에 값이 입력되지 않는다.
          그렇기 때문에 양방향 매핑시
        - 결론 : 모든 객체에 양방향에 다 넣어준다. (순수 객체 상태고려)
            - Test Case 사용시 객체가 다 있어야 무리 없이 작동
- 주의점
    - 1) 연관관계의 주인에 값을 입력하지 않을때 문제가 발생
        - 예시) Team 은 1개 Member 는 여러개
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setName("member1");

            team.getMembers().add(member);

            em.persist(member);

            // 역방향만 연관관계를 설정하고 연관관계 주인의 값을 입력하지 않을때 문제 발생할 소지 잇음
            // Member 객체에는 team 객체를 넣어 놓지 않음

- 연관관계 작성 방법(필수는 아니나 추천)
    - 연관관계 편의 메소드 사용 (개발자의 실수를 줄여줌)
        - 예시
        @Entity
        public class A {
            // 연관관계 B 세팅시 B 객체에도 A 객체를 넣어주는 것을 동시에 함
            // getter setter 의 setter 이름이 아닌 구분가능하도록 다른 이름으로 사용해주면 인식하기 편함
            public void  changeB(B b)/* setB(B b) */ {
                this.b = b;
                b.getAs().add(this);
            }
        }






