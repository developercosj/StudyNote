- 방향 : 단방향, 양방향
- 다중성 : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)
- 연관관계의 주인(Owner) : 객체 양방향 연관관계
- 객체와 테이블 연관관계
    - 객체 연관관계 : 2개
        *객체의 양방향 관계는 사실 단방향 2개라고 할 수 있다.
        회원 -> 팀 연관관계 1개 (단방향)
        팀 -> 회원 연관관계 1개 (단방향)
    - 테이블 연관관계 : 1개
        회원 <-> 팀의 연관관계 1개(무방향)
        FK 하나로 (join 이 가능하니까) 두 테이블의 연관관계 관리가 가능
- 연관관계의 주인(Owner) 정하기
    - 양방향 매핑을 할때 각 A,B 객체에 B,A 객체가 서로 포함되어 있는 연관관계일때 DB 테이블애서는 FK만 있으면 서로 관계를 가져올 수 있다(JOIN을 통해)
    - 하지만 객체의 위치에서는 A 객체 B 객체 중에 어떤 것을 바꿔야 -> FK의 키를 update 할 수 있는지에 대한 결정이 필요하다.
    - 객체의 두 관계중 하나를 연관관계의 주인으로 지정하는 것이 필요하다.
    - 연관관계의 주인만 외래키를 관리할 수 있다 (등록, 수정)
    - 주인이 아닌쪽은 읽기만 가능하다.
    - 주인은 mappedBy 속성 사용이 불가하며 주인이 아니면 mappedBy속성으로 주인을 지정해야 한다.
    - 주인으로 지정하는 객체
        - 외래키가 있는 곳으로 주인을 정할것(성능이슈등 다양한 이유로)
        - 1:N 일때 N 일때 연관관계의 주인이 된다.
        - 양방향 매핑시 연관과계의 주인에 값을 입력해야 한다.
          mappedBy 속성을 사용한 객체는 주인이 아니기때문에 update 등이 불가하고 읽기만 가능하다. 따라서 값을 넣어도 DB에 값이 입력되지 않는다.
          그렇기 때문에 양방향 매핑시
        - 결론 : 모든 객체에 양방향에 다 넣어준다. (순수 객체 상태고려)
            - Test Case 사용시 객체가 다 있어야 무리 없이 작동
- 주의점
    - 1) 연관관계의 주인에 값을 입력하지 않을때 문제가 발생
        - 예시) Team 은 1개 Member 는 여러개
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setName("member1");

            team.getMembers().add(member);

            em.persist(member);

            // 역방향만 연관관계를 설정하고 연관관계 주인의 값을 입력하지 않을때 문제 발생할 소지 잇음
            // Member 객체에는 team 객체를 넣어 놓지 않음
    - 2) 다중성
        - 다대일** : @ManyToOne
            - 다대일 단방향
                다' : @ManyToOne, JoinColumn(name="FK 키 컬럼명")
                일' : 설정할 것 없음
            - 다대일 양방향
                다' : @ManyToOne, JoinColumn(name="FK 키 컬럼명")
                일' : @OneToMany(mappedBy = "다'에서의 일' 필드변수명"),
                *일' 에서의 설정추가가 테이블에 영향을 주진 않음
        - 일대다 : @OneToMany
            - 일대다(1:N) 단방향 (1 에서 FK 키 관리)
                - *실무에서 권장하지 않음
                - 객체에서는 1에서 FK 관리를 하지만 실제로 DB에서는 당연히 N 쪽에 FK 가 있음
                - 1이 연관관계의 주인
                - 테이블 일대다 관계는 항상 다(N)쪽에 외래 키가 있음
                - 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조
                - @JoinColumn을 꼭 사용해야함 그렇지 않고 @OneToMany만 적어놓으면 조인 테이블방식을 사용함 (각각 PK 를 가진 중간테이블이 하나 생성됨)
                    #중간테이블을 강제로 생성하도록 할 수도 있음 : @JoinTable , 운영복잡, 성능확인 필요
            - 일대다(1:N) 양방향
                - 일대다 단방향 설정 + 다' 엔티티에 추가 (우회)
                    @ManyToOne
                    @JoinColumn(name = "", insertable = false, updatable = false)
                    private 다' 다;
                - 공식적으로 존재하진 않으나 우회적인 방법
                - 읽기전용 필드를 사용해서 양방향 처럼 사용하는 방법
                - 하지만 다대일 양방향을 추천
        - 일대일(1:1) : @OneToOne
            - 각각 FK 가 1개만 있다는 비즈니스 룰이 있는것
            - 주 테이블이나 대상 테이블 중에 외래 키 아무 곳에서나 고를 수 있음
            - 주 테이블에 외래키를 넣거나 대상 테이블에 외래키를 넣는 것이 가능
            - 외래키에 데이터베이스 유니크 제약조건 추가를 해야 편하게 할 수 있음(중요)
            - 많이 조회하는 (예를들어 Member 객체) 객체에 FK 가 있는 것이 나을 수 있음
            - 다대일 양방향 매핑 처럼 외래키가 있는 곳이 연관 관계의 주인으로 설정
            - 반대편은 mappedBy 적용하여 읽기전용으로 작성
            * 대상 테이블에 외래키 단방향 관계는 JPA 에서 지원되지 않음 ( 주 객체의 외래키를 업데이트 할 때 대상 테이블의 외래키가 업데이트 되지 않기 때문에 ) -> 양방향으로 만들어야 함
            - 키 설정 장소에 따른 특징
                - 주 테이블(엑세스가 많은 테이블) 에 외래키 설정 할때
                    - 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
                    - 객체지향적
                    - JPA 매핑 편리
                    - 주 테이블만 조회하면 대상 테이블에 데이터 존재여부 확인 가능
                    - 값이 없으면 외래 키에 null 허용해야하는 단점 존재
                - 대상 테이블(주테이블이 아닌 테이블)에 외래키를 설정 할때
                    - 대상 테이블에 외래 키가 존재
                    - null 값 허용하지 않아도 됨 ..
                    - 주 테이블과 대상테이블을 일대일에서 일대다 관계로 변경 시 테이블 구조 유지가능
                    - JPA 제공 프록시 기능의 한계로 지연 로딩으로 설정시에도 즉시 로딩이 됨
                        설명 :A(주 테이블), B(대상 테이블) 객체에서 A 에 FK 를 설정해 놓으면 A 의 객체만 파악하면 A 안에 FK 를 얻어서 B 의 값이 있음을 알 수 있으나
                             B 에 FK 를 설정해 놓으면 A 테이블의 객체에서 FK 를 얻기 위해 A 테이블을 보는게 아니라 B 테이블에서 확인해야 하기 때문에 무조건 즉시로딩
                             하기 때문에 지연로딩이 의미가 없어짐
        - 다대다(N:M) 방식 : @ManyToMany
            - 실전에서 쓰지 말것
            - 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음
              따라서 다대다관계를 연결 테이블을 추가해서 일대다 + 다대일 관계로 만들어야함
            - 관계형 데이터베이스와는 다르게 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계가 가능하다. (각 객체에 상대편 리스트 객체를 가질 수 있음)
            - 실무에서 사용하진 않는데 그 이유는 생성된 중간 테이블에 있는 매핑정보가 아닌 다른 정보필드를 저장하기 어려움
            - 쿼리등 실행이 복잡함
            - ManyToMany -> OneToMany , ManyToOne 으로 변경하고 생성된 중간 테이블(자동으로 그랬음)을 엔티티로 승격해서 사용하는 것을 추천
    - 3) 단방향, 양방향
        - 테이블
            - 외래 키 하나로 양쪽 조인 가능
            - 방향 개념이 없음
        - 객체
            - 참조용 필드가 있는 쪽으로만 참조 가능
            - 한쪽만 참조하면 단방향
            - 양쪽이 서로 참조하면 양방향
    - 4) 연관관계의 주인(양방향)
        - 테이블은 외래키 하나로 두 테이블이 연관관계를 맺으나 객체 양방향 관계는 참조를 2군데 작성해야 한다.
        - 2군데 중 외래키를 관리할 곳을 지정해야 한다.
        - 연관관계의 주인 : 외래키를 관리하는 참조
        - 주인의 반대편은 외래키에 영향을 주지 않고 단순 조회만 가능

- 연관관계 작성 방법(필수는 아니나 추천)
    - 연관관계 편의 메소드 사용 (개발자의 실수를 줄여줌)
        - 1:N 중 상황에 따라서 사용함
        - 예시
        @Entity
        public class A {
            // 연관관계 B 세팅시 B 객체에도 A 객체를 넣어주는 것을 동시에 함
            // getter setter 의 setter 이름이 아닌 구분가능하도록 다른 이름으로 사용해주면 인식하기 편함
            public void  changeB(B b)/* setB(B b) */ {
                this.b = b;
                b.getAs().add(this);
            }
        }

        - 연관관계 편의 메서드를 양쪽 객체에 모두 사용하면 무한 루프 문제가 발생할 수 있음
            ex) toString(), lombok, JSON 생성 라이브러리
            - lombok 에서 toString() 사용하면 문제 발생소지가 있음
            - Controller 에 Entity 를 API 반환할 시에 Entity를 변경시 API 반환값이 바껴 버리는 문제가 생기기 때문에
            DTO 로 변경하여 리턴하기 또한 무한루프가 발생할 수도 있음

- 정리
    - 단방향 연관관계로 최대한 작성할것 추천
    - 단방향 매핑으로 연관관계 매핑 설계는 다 가능하지만 실제 사용하면서 필요할때 추가하면 됨 (JPQL 사용시 필요하게 될 수 있고 그때 넣으면 됨)
    - 양방향 매핑은 반대 방향으로 조회기능이 추가된 것
    - JPQL 에서 역방향으로 탐색할 일이 많다.
    - 단방향 매핑을 잘 한 뒤 양방향을 필요할 때 추가해도된다.
    - 비즈니스 로직을 기준으로 연관관계의 주인을 선택하지 말고 외래키의 위치를 기준으로 정해야함




