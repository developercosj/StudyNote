1. 복잡도(complexity)
    - 복잡도 : 작성한 알고리즘이 시간적, 공간적 측면에서 효율적인지 판단할 수 있는 기준이 된다.
    - 시간복잡도 : 알고리즘의 실행 시간 정량화, 공간복잡도 : 실행하는데 필요한 메모리 사용량 정량화
    - 시간복잡도 : 코드 혹은 알고리즘의 실행 시간과 데이터의 상관관계, 시간과 입력데이터의 함수 관계
        1. 빅오표기법 : 코딩 테스트 효율성 검사 사용 시간 복잡도, 알고리즘이 겪을 수 있는 최악의 경우에 걸리는 시간과 입력 간의 상관관계 표기
            - O(N) : 입력 크기가 N 이고 이에 비례하는 시간이 걸릴 때
                - 전체 배열을 순회할 때 O(N)의 시간복잡도를 갖게 된다.

        *알고리즘과 시간 복잡도
            | 알고리즘 | 시간 복잡도 |
            | --- | --- |
            | 이진 탐색 | O(logN) |
            | 선형 탐색 | O(N) |
            | 정렬 | O(NlogN) |
            | 조합 | O(2의 n승) |
            | 순열 | O(N!) |

    *특별한 로직 없이 실행되는 사칙연산과 같은 단순 연산의 시간 복잡도 : O(1)

2. 자료구조
    - 선형 자료구조
        - 연속적으로 데이터가 나열되는 자료구조
        - 예 : 배열, 리스트, 스택, 큐
        - 배열
            - 정해진 크기만큼 데이터가 일렬로 저장(정적 자료구조)
            - 요소, 인덱스
            - 크기가 10이면 데이터가 5개가 있더라도 10의 크기이기 때문에 메모리가 낭비될 수 있다.
            - 특정 인덱스의 데이터에 접근하는 데 걸리는 시간 복잡도 : O(1) → 첫번째 데이터에 대한 주소 값에 (데이터 타입의 메모리 크기) * (접근하려는 데이터의 인덱스) 를 더하면 됨
            - 배열의 검색 시간 복잡도는 O(n) → 배열에서 특정 데이터를 검색하려면 0부터 특정데이터가 있는 n번째 인덱스까지 탐색이 필요
            - 배열 삽입의 시간 복잡도는 O(n) 또는 O(1) → 추가 시 원래 그 위치에 있던 기존 데이터를 뒤로 한 칸 미뤄야 한다. 따라서 시간복잡도는 O(n) 이고, 배열의 가용 공간보다 배열 크기가 작은 경우 맨 마지막에 추가시 기존 배열의 마지막 인덱스 + 1 로 접근한 후 삽입하면 된다.
            - 배열 삭제 시간 복잡도는 O(n) 또는 O(1) → 삭제할 떄 배열 전체의 데이터를 한 칸씩 앞으로 이동하는 연산을 수행하므로 시간복잡도 O(n) 이고 만약 마지막 데이터를 삭제할 때는 마지막 인덱스에 접근해 삭제하고 위치 이동이 없기 때문에 시간복잡도는 O(1) 이다.
        - 연결 리스트
            - 배열과 달리 크기가 정해져 있지 않은 동적 자료구조
            - 여러개의 노드로 구성 (데이터와 다음 노드가 저장된 주소 값을 가진다.)
            - 헤드포인터(첫번째 노드)와 테일포인터(마지막 노드)로 시작과 끝을 알 수 있다.
            - 데이터의 추가 및 삭제가 자유롭다. 추가시 기존 노드의 위치를 배열처럼 변경하지 않아도 된다.
            - 배열과 달리 인덱스가 없어서 특정 위치의 데이터에 접근하는데 배열보다 시간이 오래 걸린다.
            - 검색 O(n)
                - 특정 데이터를 검색하는 데 드는 시간 복잡도 : O(n) → 첫번째 노드부터 하나씩 값 확인 선형 탐색 필요
            - 추가 O(n)
                - O(1) : 노드를 옮길 필요 없이 이전 노드가 가리키는 노드의 주소 값을 변경하는 작업 필요
                - O(n) : 데이터를 추가하려는 위치까지 이동해야함
                - 맨앞 데이터 추가시 O(1) , 나머지 위치에 추가시 O(n)
            - 삭제 O(n)
                - O(1) : 첫 번째 데이터를 삭제하는 경우
                - O(n) : 첫 번째 데이터를 제외한 나머지 데이터 삭제시에 해당 위치까지 이동 연산 필요해서 O(n)
                - *삭제연산 자체는 O(1)
        - 스택
            - 스택은 데이터를 쌓는 형태
            - LIFO(Last In First Out) 마지막에 들어온 데이터가 먼저 나감
            - 스택은 주로 어떤 작업의 실행을 취소할 때, 웹브라우저에서 뒤로가기 할 때 등 최근에 처리한 작업들을 하나씩 꺼낼 때 사용
            - 연산자
                | 연산 | 설명 | 시간 복잡도 |
                | --- | --- | --- |
                | push | 스택에 새로운 데이터 삽입 | O(1) |
                | pop | 스택에서 가장 위에 있는 데이터 삭제 | O(1) |
                | peek | 스택에서 가장 위에 있는 데이터 확인 | O(1) |
                | isEmpty | 스택이 비어 있는지 확인 | O(1) |
                | isFull | 스택이 가득 찼는지 확인 | O(1) |
        - 큐
            - FIFO(First In First Out) : 데이터가 순차적으로 들어오고 먼저 들어온 데이터가 먼저 나감
            - front : 큐의 맨앞, rear : 큐의 맨뒤
            - 인큐(enqueue) : 큐의 맨 뒤에 데이터가 삽입
            - 디큐(dequeue) : 큐의 맨앞에서 삭제
            - ex) 준비큐, 어떤 작업 처리시 작업 요청이 들어온 순서대로 처리하기 위해 사용
            - 연산자
                | 연산 | 설명 | 시간복잡도 |
                | --- | --- | --- |
                | enqueue | 큐의 rear에 새로운 데이터 삽입 | O(1) |
                | dequeue | 큐의 front에서 데이터 삭제 | O(1) |
                | peek | 큐의 front 에 있는 데이터 확인 | O(1) |
                | isEmpty | 큐가 비어있는지 확인 | O(1) |
                | isFull | 큐가 가득찼는지 확인 | O(1) |

    - 비선형 자료구조
        - 하나의 데이터 뒤에 N 개의 데이터가 있음
        - 1:N 또는 N:N 구조
        - 계층적
        - 예 : 그래프, 트리
        - 그래프(Graph) G = (V,E)
            - 정점(vertex) = 노드(node)
            - 간선(edge)
            - 용어정리
                - 인접 : 두 정점이 간선으로 연결
                - 차수 : 정점에 연결된 간선의 수
                - 진입차수 : 해당 정점으로 향하는 간선의 수
                - 진출 차수 : 해당 정점에서 나가는 간선의 수
                - 경로 : 한 정점에서 다른 정점으로 이어지는 정점들의 리스트
                - 경로 길이 : 경로를 구성하는 간선의 수 A→B→C→D 면 3
                - 단순 경로 : 모두 다른 정점으로 구성된 경로
                - 사이클 : 한 정점에서 시작해 같은 정점으로 돌아올 수 있는 경로
            - 종류
                - 무방향 그래프 : 간선에 방향성이 없는 그래프
                    - 최대 간선 개수 = n * (n-1) /2 *n은 정점의 수
                - 방향 그래프 : 간선에 방향성이 있는 그래프
                    - A→B 와 B→A 는 다른 간선
                    - 최대 간선의 개수 = n * (n-1)
            - 경로탐색
                - 너비우선탐색(BFS, Breadth-First Search)
                    - 시작 정점에서 가까운 정점 먼저 탐색
                    - 탐색하며 큐에 삽입시 방문했던 정점인지 확인
                - 깊이우선탐색(DFS, Depth-First Search)
                    - 시작 정점에서 탐색 가능한 최대 깊이의 정점까지 탐색
                    - 재귀호출 또는 스택으로 구현 가능
        - 트리
            - 그래프의 한 종류로 사이클이 없어서 계층적 관계 표현 가능
            - 이진트리(binary tree)
                - 자식 노드가 최대 2개인 트리
                - 종류
                    - 완전 이진 트리(complete binary tree)
                        - 트리의 마지막 레벨을 제외한 모든 레벨에 노드가 채워져 있으며 마지막 레벨은 왼쪽에서부터 오른쪽으로 노드가 채워져 있는 이진 트리
                    - 포화 이진 트리
                        - 트리의 마지막 레벨까지 노드가 모두 채워져 있는 이진 트리
                    - 이진 탐색 트리(BST Binary Search Tree)
                        - 한 노드의 왼쪽 서브 트리는 해당 노드의 값보다 작은 값을 가진 노드로 구성되고, 오른쪽 서브 트리는 해당 노드의 값보다 큰 값을 가진 노드로 구성된 트리
        - 해시 테이블
            - 하나의 key에 대해 하나의 값 value 를 저장하는 형태
            - 키 → 해시함수 → 인덱스(값을 찾음)
            - 해시함수를 통해 해시(인덱스값)를 얻음, 해시로 값을 찾을 수 있음
            - 연산 시간복잡도 : O(1)
            - 해시충돌
                - 서로 다른 키에 대해 같은 해시 도출
                - 해결방법
                    - 체이닝(chaining)
                        - 해시 충돌 발생 시 같은 해시가 나오는 키의 값을 연결 리스트에 노드 저장
                        - 하나의 해시(인덱스)에 노드가 몰릴 수 있는 단점 존재
                    - 개방 주소법